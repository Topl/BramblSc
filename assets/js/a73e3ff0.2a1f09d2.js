"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[472],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,k=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return n?i.createElement(k,a(a({ref:t},d),{},{components:n})):i.createElement(k,a({ref:t},d))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:r,a[1]=s;for(var l=2;l<o;l++)a[l]=n[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7884:(e,t,n)=>{n.d(t,{Z:()=>s});var i=n(7294),r=n(9960),o=n(6550),a=n(8084);function s(e){let{children:t,path:n}=e;var s=function(){const{pathname:e}=(0,o.TH)(),{versions:t}=(0,a.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:n}=t;return e.startsWith(n)})).name||"current"}();return i.createElement(r.Z,{to:`/scaladoc/${s}/${n}`,target:"_blank"},t)}},282:(e,t,n)=>{n.d(t,{ZP:()=>c});var i=n(7462),r=(n(7294),n(3905)),o=n(7884);const a={toc:[]},s="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(s,(0,i.Z)({},a,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The following requires access to a Transaction Builder Api instance. You can initialize one using the following snippet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val transactionBuilderApi = TransactionBuilderApi.make[F](MAIN_NETWORK_ID, MAIN_LEDGER_ID)\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," is a type parameter bound to a context parameter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad[F]"),". See the ",(0,r.kt)("inlineCode",{parentName:"p"},"make"),"\nfunction's ",(0,r.kt)(o.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi$.html",mdxType:"ScaladocLink"},"signature"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"MAIN_NETWORK_ID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MAIN_LEDGER_ID")," refer to the IDs of Topl's main network and ledger, respectfully. If you\nwish to use a different network or ledger, you can find the IDs of all available networks and ledgers in\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/constants/NetworkConstants$.html",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"NetworkConstants"))," object.")))}c.isMDXComponent=!0},9239:(e,t,n)=>{n.d(t,{ZP:()=>s});var i=n(7462),r=(n(7294),n(3905));const o={toc:[]},a="wrapper";function s(e){let{components:t,...n}=e;return(0,r.kt)(a,(0,i.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"By the nature of the blockchain, a UTXO's lock is publicly\nrevealed once it's spent, rendering all other UTXOs encumbered by the same lock insecure and vulnerable to theft. To\nprevent this, we strongly recommend that all other UTXOs encumbered by the same lock are moved to a new lock. Our functions\nare designed to make this easy, however, it is up to the user to ensure that this is done.")))}s.isMDXComponent=!0},6347:(e,t,n)=>{n.d(t,{ZP:()=>s});var i=n(7462),r=(n(7294),n(3905));const o={toc:[]},a="wrapper";function s(e){let{components:t,...n}=e;return(0,r.kt)(a,(0,i.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("span",null,"On success, this function returns an unproven ",(0,r.kt)("code",null,"IoTransaction")," which can be proven and then broadcasted to the network. Once the transaction is processed and accepted on the chain, the ",n.tokenType," tokens can be used in subsequent transactions. On failure, this function returns a ",(0,r.kt)("code",null,"BuilderError")," which contains information on why it failed."))}s.isMDXComponent=!0},9758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>f,frontMatter:()=>l,metadata:()=>u,toc:()=>m});var i=n(7462),r=(n(7294),n(3905)),o=n(282),a=n(9239),s=n(6347),c=n(7884);const l={sidebar_position:1,title:"Mint Tokens",description:"Build a transaction to mint group, series, and asset tokens."},d="Build a Minting Transaction",u={unversionedId:"reference/transactions/minting",id:"reference/transactions/minting",title:"Mint Tokens",description:"Build a transaction to mint group, series, and asset tokens.",source:"@site/docs/reference/transactions/minting.mdx",sourceDirName:"reference/transactions",slug:"/reference/transactions/minting",permalink:"/BramblSc/docs/current/reference/transactions/minting",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Mint Tokens",description:"Build a transaction to mint group, series, and asset tokens."},sidebar:"referenceSidebar",previous:{title:"Build a Transaction",permalink:"/BramblSc/docs/current/category/build-a-transaction"},next:{title:"Transfer Tokens",permalink:"/BramblSc/docs/current/reference/transactions/transfer"}},p={},m=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Mint Group Constructor Tokens",id:"mint-group-constructor-tokens",level:2},{value:"Mint Series Constructor Tokens",id:"mint-series-constructor-tokens",level:2},{value:"Mint Asset Tokens",id:"mint-asset-tokens",level:2}],k={toc:m},h="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,i.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"build-a-minting-transaction"},"Build a Minting Transaction"),(0,r.kt)("p",null,"The first step to minting new tokens on the Topl Blockchain is to build an unproven minting transaction. There are three\ntypes of tokens you can mint; group constructor tokens, series constructor tokens, and asset tokens. The transaction\nbuilder offers a way to build each."),(0,r.kt)(a.ZP,{mdxType:"RevealedLock"}),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)(o.ZP,{mdxType:"InitTxBuilder"}),(0,r.kt)("h2",{id:"mint-group-constructor-tokens"},"Mint Group Constructor Tokens"),(0,r.kt)("p",null,"You can create a transaction to mint new group constructor tokens using\nthe ",(0,r.kt)(c.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildGroupMintingTransaction(Seq[Txo],Predicate,GroupPolicy,Long,LockAddress,LockAddress,Long):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"buildGroupMintingTransaction")),"\nfunction of a Transaction Builder API instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def buildGroupMintingTransaction(\n  txos:              Seq[Txo],\n  lockPredicateFrom: Lock.Predicate,\n  groupPolicy:       GroupPolicy,\n  quantityToMint:    Long,\n  mintedAddress:     LockAddress,\n  changeAddress:     LockAddress,\n  fee:               Long\n): F[Either[BuilderError, IoTransaction]]\n")),(0,r.kt)("p",null,'This function builds a transaction to mint group constructor tokens for a given Group Policy. These minted group\nconstructor tokens must be "registered" to an existing LVL UTXO. This registration UTXO is specified in the Group Policy and\nmust be included in the transaction inputs.'),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. The registration UTXO (as specified in the\n",(0,r.kt)("inlineCode",{parentName:"li"},"groupPolicy"),") must be included in this sequence. All TXOs must be encumbered by the same lock predicate, given by\n",(0,r.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,r.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,r.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"groupPolicy")," - The Group Policy for which to mint new group constructor tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"quantityToMint")," - The quantity of group constructor tokens to mint."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mintedAddress")," - A new LockAddress for which the minted group constructor tokens will be encumbered. You can create a\nnew Lock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"changeAddress")," - A new LockAddress for which all the change UTXOs from ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee.")),(0,r.kt)(s.ZP,{tokenType:"minted group constructor",mdxType:"TxReturn"}),(0,r.kt)("h2",{id:"mint-series-constructor-tokens"},"Mint Series Constructor Tokens"),(0,r.kt)("p",null,"You can create a transaction to mint new series constructor tokens using\nthe ",(0,r.kt)(c.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildSeriesMintingTransaction(Seq[Txo],Predicate,SeriesPolicy,Long,LockAddress,LockAddress,Long):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"buildSeriesMintingTransaction")),"\nfunction of a Transaction Builder API instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def buildSeriesMintingTransaction(\n  txos:              Seq[Txo],\n  lockPredicateFrom: Lock.Predicate,\n  seriesPolicy:      SeriesPolicy,\n  quantityToMint:    Long,\n  mintedAddress:     LockAddress,\n  changeAddress:     LockAddress,\n  fee:               Long\n): F[Either[BuilderError, IoTransaction]]\n")),(0,r.kt)("p",null,'This function builds a transaction to mint series constructor tokens for a given Series Policy. These minted series\nconstructor tokens must be "registered" to an existing LVL UTXO. This registration UTXO is specified in the Series Policy\nand must be included in the transaction inputs.'),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. The registration UTXO (as specified in the\n",(0,r.kt)("inlineCode",{parentName:"li"},"seriesPolicy"),") must be included in this sequence. All TXOs must be encumbered by the same lock predicate, given by\n",(0,r.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,r.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,r.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seriesPolicy")," - The Series Policy for which to mint new series constructor tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"quantityToMint")," - The quantity of series constructor tokens to mint."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mintedAddress")," - A new LockAddress for which the minted series constructor tokens will be encumbered. You can create a\nnew Lock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"changeAddress")," - A new LockAddress for which all the change UTXOs from ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee.")),(0,r.kt)(s.ZP,{tokenType:"minted series constructor",mdxType:"TxReturn"}),(0,r.kt)("h2",{id:"mint-asset-tokens"},"Mint Asset Tokens"),(0,r.kt)("p",null,"You can create a transaction to mint new asset tokens using\nthe ",(0,r.kt)(c.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildAssetMintingTransaction(AssetMintingStatement,Seq[Txo],Map[LockAddress,Predicate],Long,LockAddress,LockAddress,Option[Struct],Option[ByteString]):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"buildAssetMintingTransaction")),"\nfunction of a Transaction Builder API instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def buildAssetMintingTransaction(\n  mintingStatement:       AssetMintingStatement,\n  txos:                   Seq[Txo],\n  locks:                  Map[LockAddress, Lock.Predicate],\n  fee:                    Long,\n  mintedAssetLockAddress: LockAddress,\n  changeAddress:          LockAddress,\n  ephemeralMetadata:      Option[Struct],\n  commitment:             Option[ByteString]\n): F[Either[BuilderError, IoTransaction]]\n")),(0,r.kt)("p",null,"This function builds a transaction to mint asset tokens for a given Asset Minting Statement. These minted asset\ntokens must be created from existing group and series constructor tokens. These registration constructor tokens are\nspecified in the Asset Minting Statement and must be included in the transaction inputs."),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mintingStatement")," - The minting statement that specifies the asset to mint."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. Both the group and series constructor tokens\nthat are specified in the ",(0,r.kt)("inlineCode",{parentName:"li"},"mintingStatement")," must be included in this sequence. All TXOs must be encumbered by a lock\nfrom ",(0,r.kt)("inlineCode",{parentName:"li"},"locks"),". You can obtain these TXOs from the ",(0,r.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"locks")," - A mapping of LockAddress to their Predicate Lock. Each entry must represent a lock that encumbers some TXOs\nin ",(0,r.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mintedAssetLockAddress")," - A new LockAddress for which the minted asset tokens will be encumbered. You can create a\nnew Lock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"changeAddress")," - A new LockAddress for which all the change UTXOs from ",(0,r.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,r.kt)("a",{parentName:"li",href:"./locks"},"with the SDK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ephemeralMetadata")," - Optional ephemeral metadata to include in the minted asset tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"commitment")," - Optional commitment to include in the minted asset tokens.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenSupply")," field is present in the series constructor token used for registration, then the quantity of asset\ntokens to mint (that is defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"mintingStatement"),") has to be a multiple of this field. In this case, minting\neach multiple of ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenSupply")," quantity of assets will burn a single series constructor token.")),(0,r.kt)(s.ZP,{tokenType:"minted asset",mdxType:"TxReturn"}))}f.isMDXComponent=!0}}]);