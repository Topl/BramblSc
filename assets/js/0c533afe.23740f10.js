"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[144],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},k=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),k=a,f=p["".concat(l,".").concat(k)]||p[k]||u[k]||o;return n?r.createElement(f,i(i({ref:t},d),{},{components:n})):r.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=k;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}k.displayName="MDXCreateElement"},7884:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(7294),a=n(9960),o=n(6550),i=n(8084);function s(e){let{children:t,path:n}=e;var s=function(){const{pathname:e}=(0,o.TH)(),{versions:t}=(0,i.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:n}=t;return e.startsWith(n)})).name||"current"}();return r.createElement(a.Z,{to:`/scaladoc/${s}/${n}`,target:"_blank"},t)}},282:(e,t,n)=>{n.d(t,{ZP:()=>l});var r=n(7462),a=(n(7294),n(3905)),o=n(7884);const i={toc:[]},s="wrapper";function l(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The following requires access to a Transaction Builder Api instance. You can initialize one using the following snippet:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"val transactionBuilderApi = TransactionBuilderApi.make[F](MAIN_NETWORK_ID, MAIN_LEDGER_ID)\n")),(0,a.kt)("p",null,"Where ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is a type parameter bound to a context parameter of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Monad[F]"),". See the ",(0,a.kt)("inlineCode",{parentName:"p"},"make"),"\nfunction's ",(0,a.kt)(o.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi$.html",mdxType:"ScaladocLink"},"signature"),". For example,\nif you are using Cats Effect ",(0,a.kt)("inlineCode",{parentName:"p"},"IO"),", you can initialize the Transaction Builder Api as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.IO\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](MAIN_NETWORK_ID, MAIN_LEDGER_ID)\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"MAIN_NETWORK_ID")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"MAIN_LEDGER_ID")," refer to the IDs of Topl's main network and ledger, respectfully. If you\nwish to use a different network or ledger, you can find the IDs of all available networks and ledgers in\nthe ",(0,a.kt)(o.Z,{path:"co/topl/brambl/constants/NetworkConstants$.html",mdxType:"ScaladocLink"},(0,a.kt)("code",null,"NetworkConstants"))," object.")))}l.isMDXComponent=!0},9239:(e,t,n)=>{n.d(t,{ZP:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={toc:[]},i="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(i,(0,r.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"By the nature of the blockchain, a UTXO's lock is publicly\nrevealed once it's spent, rendering all other UTXOs encumbered by the same lock insecure and vulnerable to theft. To\nprevent this, we strongly recommend that all other UTXOs encumbered by the same lock are moved to a new lock. Our functions\nare designed to make this easy, however, it is up to the user to ensure that this is done.")))}s.isMDXComponent=!0},6347:(e,t,n)=>{n.d(t,{ZP:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={toc:[]},i="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(i,(0,r.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("span",null,"On success, this function returns an unproven ",(0,a.kt)("code",null,"IoTransaction")," which can be proven and then broadcasted to the network. Once the transaction is processed and accepted on the chain, the ",n.tokenType," tokens can be used in subsequent transactions. On failure, this function returns a ",(0,a.kt)("code",null,"BuilderError")," which contains information on why it failed."))}s.isMDXComponent=!0},5154:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>p,toc:()=>k});var r=n(7462),a=(n(7294),n(3905)),o=n(282),i=n(9239),s=n(6347),l=n(7884);const c={sidebar_position:2,title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens."},d="Build a Transfer Transaction",p={unversionedId:"reference/transactions/transfer",id:"reference/transactions/transfer",title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens.",source:"@site/docs/reference/transactions/transfer.mdx",sourceDirName:"reference/transactions",slug:"/reference/transactions/transfer",permalink:"/BramblSc/docs/current/reference/transactions/transfer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens."},sidebar:"referenceSidebar",previous:{title:"Mint Tokens",permalink:"/BramblSc/docs/current/reference/transactions/minting"},next:{title:"Scaladoc",permalink:"/BramblSc/docs/current/reference/scaladoc"}},u={},k=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Transfer a Certain Amount",id:"transfer-a-certain-amount",level:2},{value:"Transfer All Tokens",id:"transfer-all-tokens",level:2}],f={toc:k},m="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"build-a-transfer-transaction"},"Build a Transfer Transaction"),(0,a.kt)("p",null,"The first step to transferring your existing tokens on the Topl Blockchain is to build an unproven transfer transaction.\nThe transaction builder offers a way to build two types of simple transactions; transferring a certain amount of tokens\nand transferring all tokens."),(0,a.kt)(i.ZP,{mdxType:"RevealedLock"}),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)(o.ZP,{mdxType:"InitTxBuilder"}),(0,a.kt)("h2",{id:"transfer-a-certain-amount"},"Transfer a Certain Amount"),(0,a.kt)("p",null,"You can create a transaction to transfer a certain amount of a certain type of token using\nthe ",(0,a.kt)(l.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildTransferAmountTransaction(ValueTypeIdentifier,Seq[Txo],Predicate,Long,LockAddress,LockAddress,Long):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,a.kt)("code",null,"buildTransferAmountTransaction")),"\nfunction of a Transaction Builder API instance."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Transferring a specific amount of tokens using this function is not supported for some token types:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Asset type if their quantity descriptor type is NOT ",(0,a.kt)("inlineCode",{parentName:"li"},"LIQUID")),(0,a.kt)("li",{parentName:"ul"},"TOPL type if their registration is NOT ",(0,a.kt)("inlineCode",{parentName:"li"},"None")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def buildTransferAmountTransaction(\n  tokenIdentifier:      ValueTypeIdentifier,\n  txos:                 Seq[Txo],\n  lockPredicateFrom:    Lock.Predicate,\n  amount:               Long,\n  recipientLockAddress: LockAddress,\n  changeLockAddress:    LockAddress,\n  fee:                  Long\n): F[Either[BuilderError, IoTransaction]]\n")),(0,a.kt)("p",null,"This function builds a transaction to transfer a certain amount of a specified token. The transaction will also transfer\nany other tokens that are encumbered by the same predicate to a change address. Where possible, like-tokens will be\naggregated into a single output to reduce the number of UTXOs."),(0,a.kt)("p",null,"The parameters are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokenIdentifier")," - The Token Identifier denoting the type of token to transfer to the recipient. If this denotes an\nAsset Token, the quantity descriptor type of the asset must be ",(0,a.kt)("inlineCode",{parentName:"li"},"LIQUID"),". If this denotes a TOPL, the registration field\nmust be ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. All TXOs must be encumbered by the same lock\npredicate, given by ",(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,a.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,a.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"amount")," - The amount of identified Token to transfer to the recipient. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough of the\nidentified to satisfy this amount."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recipientLockAddress")," - The LockAddress for the recipient. The recipient can create a new Lock and\nLockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"changeLockAddress")," - A new LockAddress for which all the change UTXOs from ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee.")),(0,a.kt)(s.ZP,{tokenType:"transferred",mdxType:"TxReturn"}),(0,a.kt)("h2",{id:"transfer-all-tokens"},"Transfer All Tokens"),(0,a.kt)("p",null,"You can create a transaction to transfer all tokens of a certain type or all tokens regardless of type using\nthe ",(0,a.kt)(l.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildTransferAllTransaction(Seq[Txo],Predicate,LockAddress,LockAddress,Long,Option[ValueTypeIdentifier]):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,a.kt)("code",null,"buildTransferAllTransaction")),"\nfunction of a Transaction Builder API instance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def buildTransferAllTransaction(\n  txos:                 Seq[Txo],\n  lockPredicateFrom:    Lock.Predicate,\n  recipientLockAddress: LockAddress,\n  changeLockAddress:    LockAddress,\n  fee:                  Long,\n  tokenIdentifier:      Option[ValueTypeIdentifier] = None\n): F[Either[BuilderError, IoTransaction]]\n")),(0,a.kt)("p",null,"This function builds a transaction to transfer all tokens of a certain type or all tokens regardless of type. The\ntransaction will also transfer any other tokens that are encumbered by the same predicate to a change address. Where\npossible, like-tokens will be aggregated into a single output to reduce the number of UTXOs."),(0,a.kt)("p",null,"The parameters are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. All TXOs must be encumbered by the same lock\npredicate, given by ",(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,a.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,a.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recipientLockAddress")," - The LockAddress for the recipient. The recipient can create a new Lock and\nLockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"changeLockAddress")," - A new LockAddress for which all the change UTXOs from ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokenIdentifier")," - An optional Token Identifier denoting the type of token to transfer to the recipient, if applicable.\nIf this is ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),", all tokens regardless of type will be transferred to the recipient. If provided, the ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain\nsome token matching this identifier. The default value is ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,a.kt)(s.ZP,{tokenType:"transferred",mdxType:"TxReturn"}))}h.isMDXComponent=!0}}]);