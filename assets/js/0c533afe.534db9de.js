"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[144],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?r.createElement(f,i(i({ref:t},d),{},{components:n})):r.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7884:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(7294),a=n(9960),o=n(6550),i=n(8084);function s(e){let{children:t,path:n}=e;var s=function(){const{pathname:e}=(0,o.TH)(),{versions:t}=(0,i.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:n}=t;return e.startsWith(n)})).name||"current"}();return r.createElement(a.Z,{to:`/scaladoc/${s}/${n}`,target:"_blank"},t)}},9239:(e,t,n)=>{n.d(t,{ZP:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={toc:[]},i="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(i,(0,r.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"By the nature of the blockchain, a UTXO's lock is publicly\nrevealed once it's spent, rendering all other UTXOs encumbered by the same lock insecure and vulnerable to theft. To\nprevent this, we strongly recommend that all other UTXOs encumbered by the same lock are moved to a new lock. Our functions\nare designed to make this easy, however, it is up to the user to ensure that this is done.")))}s.isMDXComponent=!0},6347:(e,t,n)=>{n.d(t,{ZP:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={toc:[]},i="wrapper";function s(e){let{components:t,...n}=e;return(0,a.kt)(i,(0,r.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("span",null,"On success, this function returns an unproven ",(0,a.kt)("code",null,"IoTransaction")," which can be proven and then broadcasted to the network. Once the transaction is processed and accepted on the chain, the ",n.tokenType," tokens can be used in subsequent transactions. On failure, this function returns a ",(0,a.kt)("code",null,"BuilderError")," which contains information on why it failed."))}s.isMDXComponent=!0},5154:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>k,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var r=n(7462),a=(n(7294),n(3905)),o=n(9239),i=n(6347),s=n(7884);const l={sidebar_position:2,title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens."},c="Build a Transfer Transaction",d={unversionedId:"reference/transactions/transfer",id:"reference/transactions/transfer",title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens.",source:"@site/docs/reference/transactions/transfer.mdx",sourceDirName:"reference/transactions",slug:"/reference/transactions/transfer",permalink:"/BramblSc/docs/current/reference/transactions/transfer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Transfer Tokens",description:"Build a transaction to transfer existing tokens."},sidebar:"referenceSidebar",previous:{title:"Mint Tokens",permalink:"/BramblSc/docs/current/reference/transactions/minting"},next:{title:"Prove a Transaction",permalink:"/BramblSc/docs/current/reference/prove"}},p={},u=[{value:"Transfer a Certain Amount",id:"transfer-a-certain-amount",level:2},{value:"Example",id:"example",level:3},{value:"Transfer All Tokens",id:"transfer-all-tokens",level:2},{value:"Example",id:"example-1",level:3}],m={toc:u},f="wrapper";function k(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"build-a-transfer-transaction"},"Build a Transfer Transaction"),(0,a.kt)("p",null,"The first step to transferring your existing tokens on the Blockchain is to build an unproven transfer transaction.\nThe transaction builder offers a way to build two types of simple transactions; transferring a certain amount of tokens\nand transferring all tokens."),(0,a.kt)(o.ZP,{mdxType:"RevealedLock"}),(0,a.kt)("h2",{id:"transfer-a-certain-amount"},"Transfer a Certain Amount"),(0,a.kt)("p",null,"You can create a transaction to transfer a certain amount of a certain type of token using\nthe ",(0,a.kt)(s.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildTransferAmountTransaction(ValueTypeIdentifier,Seq[Txo],Predicate,Long,LockAddress,LockAddress,Long):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,a.kt)("code",null,"buildTransferAmountTransaction")),"\nfunction of a Transaction Builder API instance."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Transferring a specific amount of tokens using this function is not supported for some token types:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Asset type if their quantity descriptor type is NOT ",(0,a.kt)("inlineCode",{parentName:"li"},"LIQUID")),(0,a.kt)("li",{parentName:"ul"},"TOPL type if their registration is NOT ",(0,a.kt)("inlineCode",{parentName:"li"},"None")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def buildTransferAmountTransaction(\n  tokenIdentifier:      ValueTypeIdentifier,\n  txos:                 Seq[Txo],\n  lockPredicateFrom:    Lock.Predicate,\n  amount:               Long,\n  recipientLockAddress: LockAddress,\n  changeLockAddress:    LockAddress,\n  fee:                  Long\n): F[Either[BuilderError, IoTransaction]]\n")),(0,a.kt)("p",null,"This function builds a transaction to transfer a certain amount of a specified token. The transaction will also transfer\nany other tokens that are encumbered by the same predicate to a change address. Where possible, like-tokens will be\naggregated into a single output to reduce the number of UTXOs."),(0,a.kt)("p",null,"The parameters are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokenIdentifier")," - The Token Identifier denoting the type of token to transfer to the recipient. If this denotes an\nAsset Token, the quantity descriptor type of the asset must be ",(0,a.kt)("inlineCode",{parentName:"li"},"LIQUID"),". If this denotes a TOPL, the registration field\nmust be ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. All TXOs must be encumbered by the same lock\npredicate, given by ",(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,a.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,a.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"amount")," - The amount of identified Token to transfer to the recipient. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough of the\nidentified to satisfy this amount."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recipientLockAddress")," - The LockAddress for the recipient. The recipient can create a new Lock and\nLockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"changeLockAddress")," - A new LockAddress for which all the change UTXOs from ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee.")),(0,a.kt)(i.ZP,{tokenType:"transferred",mdxType:"TxReturn"}),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"The following example shows how to build a transaction to transfer 1 LVL from a height lock."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.builders.locks.LockTemplate\nimport co.topl.brambl.builders.locks.PropositionTemplate.HeightTemplate\nimport co.topl.brambl.builders.locks.LockTemplate.PredicateTemplate\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.syntax.LvlType\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\n\n// Mock address. Replace with recipient address.\nval toAddr = decodeAddress("ptetP7jshHTuV9bmPmtVLm6PtUzBMZ8iYRvAxvbGTJ5VgiEPHqCCnZ8MLLdi").toOption.get\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\nval predicateTemplate: LockTemplate[IO] = PredicateTemplate[IO](Seq(HeightTemplate("header", 1, Long.MaxValue)), 1)\n\n// Transaction building starts here:\nval tx = for {\n  fromLock <- predicateTemplate.build(List.empty).map(_.toOption.get)\n  fromAddr <- transactionBuilderApi.lockAddress(fromLock)\n  fromTxos <- GenusQueryAlgebra.make[IO](channelResource).queryUtxo(fromAddr)\n  // highlight-next-line\n  res <- transactionBuilderApi.buildTransferAmountTransaction(LvlType, fromTxos, fromLock.getPredicate, 1L, toAddr, toAddr, 1L)\n} yield res\n\ntx.unsafeRunSync()\n')),(0,a.kt)("h2",{id:"transfer-all-tokens"},"Transfer All Tokens"),(0,a.kt)("p",null,"You can create a transaction to transfer all tokens of a certain type or all tokens regardless of type using\nthe ",(0,a.kt)(s.Z,{path:"co/topl/brambl/builders/TransactionBuilderApi.html#buildTransferAllTransaction(Seq[Txo],Predicate,LockAddress,LockAddress,Long,Option[ValueTypeIdentifier]):F[Either[BuilderError,IoTransaction]]",mdxType:"ScaladocLink"},(0,a.kt)("code",null,"buildTransferAllTransaction")),"\nfunction of a Transaction Builder API instance."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def buildTransferAllTransaction(\n  txos:                 Seq[Txo],\n  lockPredicateFrom:    Lock.Predicate,\n  recipientLockAddress: LockAddress,\n  changeLockAddress:    LockAddress,\n  fee:                  Long,\n  tokenIdentifier:      Option[ValueTypeIdentifier] = None\n): F[Either[BuilderError, IoTransaction]]\n")),(0,a.kt)("p",null,"This function builds a transaction to transfer all tokens of a certain type or all tokens regardless of type. The\ntransaction will also transfer any other tokens that are encumbered by the same predicate to a change address. Where\npossible, like-tokens will be aggregated into a single output to reduce the number of UTXOs."),(0,a.kt)("p",null,"The parameters are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"txos")," - A sequence of TXOs to be the inputs of the created transaction. All TXOs must be encumbered by the same lock\npredicate, given by ",(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom"),". You can obtain these TXOs from the ",(0,a.kt)("a",{parentName:"li",href:"../rpc#querying-utxos"},"RPC queries"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"lockPredicateFrom")," - The Predicate Lock that encumbers all the TXOs in ",(0,a.kt)("inlineCode",{parentName:"li"},"txos"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"recipientLockAddress")," - The LockAddress for the recipient. The recipient can create a new Lock and\nLockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"changeLockAddress")," - A new LockAddress for which all the change UTXOs from ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," will be encumbered. You can create a new\nLock and LockAddress ",(0,a.kt)("a",{parentName:"li",href:"../locks"},"with the SDK"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fee")," - The transaction fee. The ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain enough LVLs to satisfy this fee."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokenIdentifier")," - An optional Token Identifier denoting the type of token to transfer to the recipient, if applicable.\nIf this is ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),", all tokens regardless of type will be transferred to the recipient. If provided, the ",(0,a.kt)("inlineCode",{parentName:"li"},"txos")," must contain\nsome token matching this identifier. The default value is ",(0,a.kt)("inlineCode",{parentName:"li"},"None"),".")),(0,a.kt)(i.ZP,{tokenType:"transferred",mdxType:"TxReturn"}),(0,a.kt)("h3",{id:"example-1"},"Example"),(0,a.kt)("p",null,"The following example shows how to build a transaction to transfer all known tokens from a height lock."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.builders.locks.LockTemplate\nimport co.topl.brambl.builders.locks.PropositionTemplate.HeightTemplate\nimport co.topl.brambl.builders.locks.LockTemplate.PredicateTemplate\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\n\n// Mock address. Replace with recipient address.\nval toAddr = decodeAddress("ptetP7jshHTuV9bmPmtVLm6PtUzBMZ8iYRvAxvbGTJ5VgiEPHqCCnZ8MLLdi").toOption.get\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\nval predicateTemplate: LockTemplate[IO] = PredicateTemplate[IO](Seq(HeightTemplate("header", 1, Long.MaxValue)), 1)\n\n// Transaction building starts here:\nval tx = for {\n  fromLock <- predicateTemplate.build(List.empty).map(_.toOption.get)\n  fromAddr <- transactionBuilderApi.lockAddress(fromLock)\n  fromTxos <- GenusQueryAlgebra.make[IO](channelResource).queryUtxo(fromAddr)\n  // highlight-next-line\n  res <- transactionBuilderApi.buildTransferAllTransaction(fromTxos, fromLock.getPredicate, toAddr, toAddr, 1L)\n} yield res\n\ntx.unsafeRunSync()\n')))}k.isMDXComponent=!0}}]);