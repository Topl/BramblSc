"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[429],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=l,f=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return a?n.createElement(f,r(r({ref:t},p),{},{components:a})):n.createElement(f,r({ref:t},p))}));function f(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:l,r[1]=o;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},8482:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(7462),l=(a(7294),a(3905));const i={sidebar_position:3},r="Usage of the Service Kit",o={unversionedId:"service-kit/usage",id:"service-kit/usage",title:"Usage of the Service Kit",description:"In this document we are showing how to use the service kit to interact with the",source:"@site/docs/service-kit/usage.md",sourceDirName:"service-kit",slug:"/service-kit/usage",permalink:"/BramblSc/docs/current/service-kit/usage",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"serviceKitSidebar",previous:{title:"Overview of Service Kit",permalink:"/BramblSc/docs/current/service-kit/big-picture"}},s={},c=[{value:"Creating a Vault and a Wallet Database",id:"creating-a-vault-and-a-wallet-database",level:2},{value:"Updating the Wallet Database",id:"updating-the-wallet-database",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,l.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"usage-of-the-service-kit"},"Usage of the Service Kit"),(0,l.kt)("p",null,"In this document we are showing how to use the service kit to interact with the\nTopl Network. We will be showing code snippets in Scala."),(0,l.kt)("h2",{id:"creating-a-vault-and-a-wallet-database"},"Creating a Vault and a Wallet Database"),(0,l.kt)("p",null,"The first step is to create a vault. The vault is where the master key is stored."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// You can run this code using scala-cli. Save it in a file called `create-vault.sc` and run it with `scala-cli create-vault.sc`\n//> using scala 2.13\n//> using repository "sonatype-s01:releases"\n//> using dep "co.topl::service-kit:2.0.0-beta2"\n//> using dep "org.typelevel::cats-core:2.10.0"\n\nimport cats.effect.IO\nimport co.topl.brambl.wallet.WalletApi\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.constants.NetworkConstants\n\nimport cats.effect.std\nimport io.circe.syntax._\nimport co.topl.crypto.encryption.VaultStore.Codecs._\nimport cats.effect.unsafe.implicits.global\n\nimport java.io.File\n\ncase class CreateWallet(file: String, password: String) {\n  val walletKeyApi = WalletKeyApi.make[IO]()\n  val walletApi = WalletApi.make(walletKeyApi)\n  val walletStateApi = WalletStateApi.make[IO](WalletStateResource.walletResource(file), walletApi)\n\n  val createWallet = for {\n    wallet <- walletApi\n      .createNewWallet(\n        password.getBytes(),\n        Some("passphrase")\n      )\n      .map(_.fold(throw _, identity))\n    keyPair <- walletApi\n      .extractMainKey(\n        wallet.mainKeyVaultStore,\n        password.getBytes()\n      )\n      .flatMap(\n        _.fold(\n          _ =>\n            IO.raiseError(\n              new Throwable("No input file (should not happen)")\n            ),\n          IO(_)\n        )\n      )\n    _ <- std.Console[IO].println("Wallet: " + new String(wallet.mainKeyVaultStore.asJson.noSpaces))\n    _ <- std.Console[IO].println("Mnemonic: "+ wallet.mnemonic.mkString(","))\n    _ <- walletStateApi.initWalletState(\n      NetworkConstants.PRIVATE_NETWORK_ID,\n      NetworkConstants.MAIN_LEDGER_ID,\n      keyPair\n    )\n  } yield ()\n\n}\n\nval file = "myWallet.db"\nval password = "password"\n// we delete the wallet before creating it\nnew File(file).delete()\n\nval wallet = CreateWallet(file, password)\n// Create the wallet using:\nwallet.createWallet.unsafeRunSync()\n')),(0,l.kt)("p",null,"This will create an encrypted vault and print it to the console. The vault is\nencrypted with the password provided. It will also create a wallet state database\nfile called ",(0,l.kt)("inlineCode",{parentName:"p"},"myWallet.db")," and print the mnemonic to recover the wallet to the\nstandard ouput."),(0,l.kt)("p",null,"This code has several parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"first, it creates a wallet in memory (the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletApi.createNewWallet")," function)"),(0,l.kt)("li",{parentName:"ul"},"then, it extracts the main key from the wallet (the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletApi.extractMainKey")," function)"),(0,l.kt)("li",{parentName:"ul"},"finally, it initializes the wallet database (the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletStateApi.initWalletState")," function)")),(0,l.kt)("h2",{id:"updating-the-wallet-database"},"Updating the Wallet Database"),(0,l.kt)("p",null,"Users must update the wallet state whenever one of their child keys is used to create a new transaction."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// You can run this code using scala-cli. Save it in a file called `create-vault.sc` and run it with `scala-cli create-vault.sc`\n//> using scala 2.13\n//> using repository "sonatype-s01:releases"\n//> using dep "co.topl::service-kit:2.0.0-beta2"\n//> using dep "org.typelevel::cats-core:2.10.0"\n\nimport cats.effect.IO\nimport co.topl.brambl.wallet.WalletApi\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.constants.NetworkConstants\nimport cats.effect.std\nimport io.circe.syntax._\nimport co.topl.crypto.encryption.VaultStore.Codecs._\nimport cats.effect.unsafe.implicits.global\nimport cats.implicits.toTraverseOps\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.utils.Encoding\nimport quivr.models.VerificationKey\n\nimport java.io.File\n\ncase class CreateWallet(file: String, password: String) {\n  val walletKeyApi = WalletKeyApi.make[IO]()\n  val walletApi = WalletApi.make(walletKeyApi)\n  val walletStateApi = WalletStateApi.make[IO](WalletStateResource.walletResource(file), walletApi)\n\n  val createWallet = for {\n    wallet <- walletApi\n      .createNewWallet(\n        password.getBytes(),\n        Some("passphrase")\n      )\n      .map(_.fold(throw _, identity))\n    keyPair <- walletApi\n      .extractMainKey(\n        wallet.mainKeyVaultStore,\n        password.getBytes()\n      )\n      .flatMap(\n        _.fold(\n          _ =>\n            IO.raiseError(\n              new Throwable("No input file (should not happen)")\n            ),\n          IO(_)\n        )\n      )\n    _ <- std.Console[IO].println("Wallet: " + new String(wallet.mainKeyVaultStore.asJson.noSpaces))\n    _ <- std.Console[IO].println("Mnemonic: "+ wallet.mnemonic.mkString(","))\n    // Initialize the wallet state:\n    _ <- walletStateApi.initWalletState(\n      NetworkConstants.PRIVATE_NETWORK_ID,\n      NetworkConstants.MAIN_LEDGER_ID,\n      keyPair\n    )\n  } yield ()\n\n  // highlight-start\n  val updateWallet = for {\n    indices <- IO.pure(Indices(1, 1, 2))\n    lock <- walletStateApi.getLock("self", "default", indices.z).map(_.get)\n    lockAddress <- TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).lockAddress(lock).map(_.toBase58())\n    lockPredicate = Encoding.encodeToBase58Check(lock.getPredicate.toByteArray)\n    parentVk <- walletStateApi.getEntityVks("self", "default")\n      .map(_.sequence.head.map(pVk => VerificationKey.parseFrom(Encoding.decodeFromBase58(pVk).toOption.get)))\n    vk <- parentVk.map(pVk => walletApi.deriveChildVerificationKey(pVk, indices.z)\n      .map(cVk => Encoding.encodeToBase58(cVk.toByteArray))).sequence\n    _ <- walletStateApi.updateWalletState(lockPredicate, lockAddress, Some("ExtendedEd25519"), vk, indices)\n  } yield ()\n  // highlight-end\n}\n\nval file = "myWallet.db"\nval password = "password"\n// we delete the wallet before creating it\nnew File(file).delete()\n\nval wallet = CreateWallet(file, password)\nwallet.createWallet.unsafeRunSync()\n\n// Update the wallet using:\n// highlight-next-line\nwallet.updateWallet.unsafeRunSync()\n')),(0,l.kt)("p",null,"This builds off of the example from the previous section. A new part is added to update the wallet state."),(0,l.kt)("p",null,"This addition has several parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"first, it sets the indices to use for the update. Here we chose (x=1, y=1, z=2). Per the ",(0,l.kt)("inlineCode",{parentName:"li"},"initWalletState"),', (x=1, y=1) represents\nthe "self" fellowship and the "default" template.'),(0,l.kt)("li",{parentName:"ul"},"then, it creates the lock for these indices. We use the ",(0,l.kt)("inlineCode",{parentName:"li"},"getLock")," function to retrieve the lock from the wallet state\nfor ",(0,l.kt)("inlineCode",{parentName:"li"},"self"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"default")," and z=2 (per the indices chosen). We know this fellowship and default template exist because it was\ninitialized per ",(0,l.kt)("inlineCode",{parentName:"li"},"initWalletState"),"."),(0,l.kt)("li",{parentName:"ul"},"then, it creates the lock address from the lock. We used the TransactionBuilder to accomplish this, however, you can\nbuild one manually if you desire."),(0,l.kt)("li",{parentName:"ul"},"then, it retrieves the predicate from the lock and encodes it to base58."),(0,l.kt)("li",{parentName:"ul"},"then, it retrieves the parent verification key from the wallet existing state using ",(0,l.kt)("inlineCode",{parentName:"li"},"getEntityVks"),' for the "self"\nfellowship and the "default" template. We know this fellowship and default template exist because it was\ninitialized per ',(0,l.kt)("inlineCode",{parentName:"li"},"initWalletState"),". "),(0,l.kt)("li",{parentName:"ul"},"then, it derives the child verification key from the parent verification key using the ",(0,l.kt)("inlineCode",{parentName:"li"},"deriveChildVerificationKey")," for\nthe new z=2 index."),(0,l.kt)("li",{parentName:"ul"},"finally, it updates the wallet state using the ",(0,l.kt)("inlineCode",{parentName:"li"},"updateWalletState")," function.")))}u.isMDXComponent=!0}}]);