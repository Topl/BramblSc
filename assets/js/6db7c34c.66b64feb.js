"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[838],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5049:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3,title:"Mint Custom Asset",description:"Mint custom Asset tokens from scratch"},i=void 0,s={unversionedId:"tutorials/tutorials/mint-asset",id:"tutorials/tutorials/mint-asset",title:"Mint Custom Asset",description:"Mint custom Asset tokens from scratch",source:"@site/docs/tutorials/tutorials/mint-asset.md",sourceDirName:"tutorials/tutorials",slug:"/tutorials/tutorials/mint-asset",permalink:"/BramblSc/docs/current/tutorials/tutorials/mint-asset",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Mint Custom Asset",description:"Mint custom Asset tokens from scratch"},sidebar:"tutorialsSidebar",previous:{title:"Transfer Tokens",permalink:"/BramblSc/docs/current/tutorials/tutorials/simple-transfer"}},l={},u=[{value:"Use Case",id:"use-case",level:2},{value:"Set-Up",id:"set-up",level:2},{value:"Step 1: Mint Group Constructor Tokens",id:"step-1-mint-group-constructor-tokens",level:2},{value:"Query Genus Funds",id:"query-genus-funds",level:3},{value:"Create Group Policy",id:"create-group-policy",level:3},{value:"Generate a New Lock Address",id:"generate-a-new-lock-address",level:3},{value:"Create Transaction",id:"create-transaction",level:3},{value:"Prove Transaction",id:"prove-transaction",level:3},{value:"Broadcast Transaction",id:"broadcast-transaction",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3},{value:"Step 2: Mint Series Constructor Tokens",id:"step-2-mint-series-constructor-tokens",level:2},{value:"Query Genus Funds",id:"query-genus-funds-1",level:3},{value:"Create Series Policy",id:"create-series-policy",level:3},{value:"Generate a New Lock Address",id:"generate-a-new-lock-address-1",level:3},{value:"Create Transaction",id:"create-transaction-1",level:3},{value:"Prove and Broadcast Transaction",id:"prove-and-broadcast-transaction",level:3},{value:"Putting it all together",id:"putting-it-all-together-1",level:3},{value:"Step 3: Mint Asset Tokens",id:"step-3-mint-asset-tokens",level:2},{value:"Query Genus Funds",id:"query-genus-funds-2",level:3},{value:"Create Asset Minting Statement",id:"create-asset-minting-statement",level:3},{value:"Generate a New Lock Address",id:"generate-a-new-lock-address-2",level:3},{value:"Create Transaction",id:"create-transaction-2",level:3},{value:"Prove and Broadcast Transaction",id:"prove-and-broadcast-transaction-1",level:3},{value:"Putting it all together",id:"putting-it-all-together-2",level:3}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"use-case"},"Use Case"),(0,r.kt)("p",null,"To mint a new custom asset."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Objectives:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mint Group Constructor tokens"),(0,r.kt)("li",{parentName:"ul"},"Mint Series Constructor tokens"),(0,r.kt)("li",{parentName:"ul"},"Mint Asset Tokens")),(0,r.kt)("h2",{id:"set-up"},"Set-Up"),(0,r.kt)("p",null,"To follow along with this tutorial, you will need to initialize and fund a wallet with some LVLs. "),(0,r.kt)("p",null,"If you were following the instructions in the ",(0,r.kt)("a",{parentName:"p",href:"./obtain-funds"},"Load Wallet with Funds")," tutorial, the code to set up the\nSenders wallet should look something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Initializing a Wallet and Funding it with LVLs"',title:'"Initializing',a:!0,Wallet:!0,and:!0,Funding:!0,it:!0,with:!0,'LVLs"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.{Datum, Event}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{LvlType, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps, int128AsBigInt}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n  val filePath = Paths.get(tutorialDir, fileName).toString\n  new File(filePath).delete() // Clear the file if it already exists\n  filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, mainKeyPair.toOption.get)\n} yield mainKeyPair\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n  _ <- initializeWallet\n  heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)\n  heightAddress <- txBuilder.lockAddress(heightLock.get)\n  txos <- genusQueryApi.queryUtxo(heightAddress)\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  tx <- txBuilder.buildTransferAmountTransaction(\n    LvlType,\n    txos,\n    heightLock.get.getPredicate,\n    100L,\n    sigAddress,\n    heightAddress,\n    1L\n  )\n} yield tx.toOption.get\n\nval proveAndValidateResult = for {\n  tx <- unprovenTransaction\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  ctx = Context[IO](tx, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  provenTx <- proveAndValidateResult\n  txId <- bifrostQuery.broadcastTransaction(provenTx.toOption.get)\n} yield txId\n\nbroadcastTransaction.unsafeRunSync()\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\n// optionally view your funds\nval queryFunds = for {\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,r.kt)("p",null,"After running that file, you should see that the Sender's wallet has been initialized with 100 LVLs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"LvlType: 100\n")),(0,r.kt)("p",null,"Keep the same local node instance running. We will be using it for the rest of this tutorial."),(0,r.kt)("h2",{id:"step-1-mint-group-constructor-tokens"},"Step 1: Mint Group Constructor Tokens"),(0,r.kt)("p",null,"Before we can mint a new Asset Token, we must first own Group Constructor Tokens. These Constructor Tokens will be\nused to mint Asset Tokens. Group Constructor Tokens are minted for a given Group Policy."),(0,r.kt)("h3",{id:"query-genus-funds"},"Query Genus Funds"),(0,r.kt)("p",null,'From wallet initialization (in the Set-Up section), our wallet has 100 LVLs encumbered by a 1-of-1 Signature Lock stored\nat (fellowship="self", template="default", nextInteraction=1). To obtain the funds, we must query Genus for the UTXOs. This is similar\nto the section ',(0,r.kt)("a",{parentName:"p",href:"./obtain-funds#query-genesis-funds"},"Query Genesis Funds")," in the Obtain Funds tutorial, however, the parameters for\n",(0,r.kt)("inlineCode",{parentName:"p"},"getLock")," in the first step is different."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'inputLock <- walletStateApi.getLock("self", "default", 1)\ninputAddr <- transactionBuilderApi.lockAddress(inputLock)\ntxos <- genusQueryApi.queryUtxo(inputAddr)\n')),(0,r.kt)("h3",{id:"create-group-policy"},"Create Group Policy"),(0,r.kt)("p",null,"The Group Policy will be used to mint Group Constructor Tokens. The Group Policy must be associated to an existing\nUTXO that contains LVLs. Most commonly, this will be the UTXO that contains the LVLs for the transaction fee. In this\ntutorial, we will use the UTXO that contains the 100 LVLs. To see all fields of a Group Policy,\nsee ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Topl/tips/tree/main/TIP-0003#group-policy"},"TIP-0003"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'GroupPolicy("Group Policy Label", txos.head.outputAddress)\n')),(0,r.kt)("h3",{id:"generate-a-new-lock-address"},"Generate a New Lock Address"),(0,r.kt)("p",null,"Whenever we create a new transaction, we must generate new lock addresses to receive the funds and the change.\nFor simplicity in this tutorial, we will use the same lock address for both the minted group constructor tokens and the change."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"For this tutorial, we will generate a LockAddress for a 1-of-1 Digital Signature Lock for the Transaction Outputs. This is\nidentical to Step 3 under ",(0,r.kt)("a",{parentName:"li",href:"./simple-transfer#create-transaction"},"Create Transaction")," in the Transfer Tokens tutorial.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'outputLock <- walletStateApi.getLock("self", "default", 2)\n'))),(0,r.kt)("li",{parentName:"ol"},"Since we are creating a new LockAddress, we must update the Wallet State with information to unlock the lock. We did\nnot have to do this step in the Set-Up since Wallet State Initialization populates the information for the initial Signature\nLock at indices (1, 1, 1). This is identical to Step 4 under ",(0,r.kt)("a",{parentName:"li",href:"./simple-transfer#create-transaction"},"Create Transaction"),"\nin the Transfer Tokens tutorial.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'walletStateApi.updateWalletState(\n  outputPredicate, // The predicate contained in outputLock\n  outputAddress, // The LockAddress of the outputLock\n  Some("ExtendedEd25519"), // The signing routine of the Signature Lock\n  outputVk, // The verification key of the Signature Lock. This is the same as deriving the main key with indices (1, 1, 2)\n  Indices(1,1,2) // The indices of the Signature Lock\n)\n')))),(0,r.kt)("h3",{id:"create-transaction"},"Create Transaction"),(0,r.kt)("p",null,"Using everything we generated in this section, we can finally build the transaction using the Transaction Builder API.\nWe will be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"buildGroupMintingTransaction")," function.\nRead ",(0,r.kt)("a",{parentName:"p",href:"../../reference/transactions/minting#mint-group-constructor-tokens"},"Mint Group Constructor Tokens")," for more\ninformation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).buildGroupMintingTransaction(\n txos,  // The UTXOs we queried from "Query Genus Funds"\n inputLock.getPredicate, // The existing lock we retrieved from "Query Genus Funds"\n groupPolicy, // The group policy we created from "Create Group Policy"\n 5L, // The amount of Group Constructor Tokens we want to mint\n mintedAddress, // The lock address we created from "Generate a New Lock Address"\n changeAddress, // The lock address we created from "Generate a New Lock Address"\n 1L // An arbitrary fee amount\n)\n')),(0,r.kt)("h3",{id:"prove-transaction"},"Prove Transaction"),(0,r.kt)("p",null,"Once we have built the unproven transaction, we must prove (and then validate) it. This is identical\nto ",(0,r.kt)("a",{parentName:"p",href:"./simple-transfer#prove-transaction"},"Prove Transaction")," from the Transfer Tokens tutorial."),(0,r.kt)("h3",{id:"broadcast-transaction"},"Broadcast Transaction"),(0,r.kt)("p",null,"Once the transaction is proven and validated, the Sender can broadcast the transaction to the network. This is exactly\nidentical to the ",(0,r.kt)("a",{parentName:"p",href:"./obtain-funds#step-4-broadcast-transaction"},"Broadcast Transaction")," section from previous tutorials."),(0,r.kt)("h3",{id:"putting-it-all-together"},"Putting it all together"),(0,r.kt)("p",null,"Your code should look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Mint Group Constructor Tokens"',title:'"Mint',Group:!0,Constructor:!0,'Tokens"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.Event.GroupPolicy\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.utils.Encoding\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport quivr.models.VerificationKey\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\n// Replace with the desired location for your key file\nval keyFile = Paths.get(tutorialDir, "keyfile.json").toString\n// Replace with the desired location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n  inputLock <- walletStateApi.getLock("self", "default", 1)\n  inputAddress <- txBuilder.lockAddress(inputLock.get)\n  txos <- genusQueryApi.queryUtxo(inputAddress)\n  groupPolicy = GroupPolicy("Group Policy Label", txos.head.outputAddress)\n  outputLock <- walletStateApi.getLock("self", "default", 2)\n  outputAddress <- txBuilder.lockAddress(outputLock.get)\n  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>\n    // Derive the verification key at path 1/1/2 (used in outputLock)\n    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 2)\n  }\n  _ <- walletStateApi.updateWalletState(\n    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),\n    outputAddress.toBase58(),\n    Some("ExtendedEd25519"),\n    Some(Encoding.encodeToBase58(outputVk.toByteArray)),\n    Indices(1, 1, 2)\n  )\n  tx <- txBuilder.buildGroupMintingTransaction(\n    txos,\n    inputLock.get.getPredicate,\n    groupPolicy,\n    5L,\n    outputAddress,\n    outputAddress,\n    1L\n  )\n} yield tx.toOption.get\n\nval provenTx = for {\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  tx <- unprovenTransaction\n  ctx = Context[IO](tx, 50, _ => None)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res.toOption.get\n\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  tx <- provenTx\n  _ <- bifrostQuery.broadcastTransaction(tx)\n} yield ()\n\nbroadcastTransaction.unsafeRunSync()\n\nval queryFunds = for {\n  // The tokens were sent to the address derived from (self, default, 2)\n  sigLock <- walletStateApi.getLock("self", "default", 2)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value =>\n  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"\n)\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,r.kt)("p",null,"Try running the code. If all went well, you should see that you have 99 LVLs and 5 Group Constructor Token in your wallet,\nready to be spent by you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"LvlType$: 99\nGroupType: 5\n")),(0,r.kt)("p",null,"Keep the same local node instance running."),(0,r.kt)("h2",{id:"step-2-mint-series-constructor-tokens"},"Step 2: Mint Series Constructor Tokens"),(0,r.kt)("p",null,"Before we can mint a new Asset Token, we must also own Series Constructor Tokens. These Constructor Tokens will be\nused to mint Asset Tokens. Series Constructor Tokens are minted for a given Series Policy. The steps to mint Series Constructor\nTokens are very similar to minting Group Constructor Tokens, consequently, this section will reference prior sections of this\ntutorial where possible."),(0,r.kt)("h3",{id:"query-genus-funds-1"},"Query Genus Funds"),(0,r.kt)("p",null,'From the previous section, our wallet should have 99 LVLs and 5 Group Constructor Tokens. encumbered by a 1-of-1 Signature\nLock stored at (fellowship="self", template="default", nextInteraction=2). To obtain the funds, we must query Genus for\nthe UTXOs. This is very similar to the ',(0,r.kt)("a",{parentName:"p",href:"#query-genus-funds"},"previous section"),", however, we are using ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=2"),"\ninstead of ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=1"),"."),(0,r.kt)("h3",{id:"create-series-policy"},"Create Series Policy"),(0,r.kt)("p",null,"We need to create the Series Policy that will be used to mint Series Constructor Tokens. This is similar to\n",(0,r.kt)("a",{parentName:"p",href:"#create-group-policy"},"creating a group policy"),", however, a Series Policy has different fields. To see all fields of a\nSeries Policy, see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Topl/tips/tree/main/TIP-0003#series-policy"},"TIP-0003"),"."),(0,r.kt)("p",null,"Identical to the Group Policy, the Series Policy must be associated to an existing UTXO\nthat contains LVLs (the ",(0,r.kt)("inlineCode",{parentName:"p"},"registrationUtxo")," field). Most commonly, this will be the UTXO that contains the LVLs for the\ntransaction fee. In this tutorial, we will use the UTXO that contains the 99 LVLs. Since our UTXO with 99 LVLs is encumbered\nby the same Lock Address as our UTXO with 5 Group Constructor Tokens, we will need to filter out the TXOs from the previous\nsection. "),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'SeriesPolicy("Series Policy Label", registrationUtxo = txos.filter(_.transactionOutput.value.value.typeIdentifier == LvlType).head.outputAddress)\n')),(0,r.kt)("h3",{id:"generate-a-new-lock-address-1"},"Generate a New Lock Address"),(0,r.kt)("p",null,"Since we will create a new transaction, we need to generate a new Lock Address to encumber the transaction outputs. Mirroring\nthe ",(0,r.kt)("a",{parentName:"p",href:"#generate-a-new-lock-address"},"Group Constructor section"),", we will use the same lock address for both the minted series\nconstructor tokens and the change."),(0,r.kt)("p",null,"This is very similar to the linked section, however, we are using ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=3")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=2"),". In\nother words, we are deriving the verification key at path ",(0,r.kt)("inlineCode",{parentName:"p"},"1/1/3")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"self/default/3"),")."),(0,r.kt)("h3",{id:"create-transaction-1"},"Create Transaction"),(0,r.kt)("p",null,"Using everything we generated in this section, we can finally build the transaction using the Transaction Builder API.\nWe will be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"buildSeriesMintingTransaction")," function.\nRead ",(0,r.kt)("a",{parentName:"p",href:"../../reference/transactions/minting#mint-series-constructor-tokens"},"Mint Series Constructor Tokens")," for more information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).buildSeriesMintingTransaction(\n  txos,  // The UTXOs we queried from "Query Genus Funds"\n  inputLock.getPredicate, // The existing lock we retrieved from "Query Genus Funds"\n  seriesPolicy, // The group policy we created from "Create Series Policy"\n  5L, // The amount of Group Constructor Tokens we want to mint\n  mintedAddress, // The lock address we created from "Generate a New Lock Address"\n  changeAddress, // The lock address we created from "Generate a New Lock Address"\n  1L // An arbitrary fee amount\n)\n')),(0,r.kt)("h3",{id:"prove-and-broadcast-transaction"},"Prove and Broadcast Transaction"),(0,r.kt)("p",null,"Mirroring the previous section, after we build the transaction, we need to prove, validate, and broadcast the transaction.\nThis is identical to the ",(0,r.kt)("a",{parentName:"p",href:"#prove-transaction"},"Prove Transaction")," and ",(0,r.kt)("a",{parentName:"p",href:"#broadcast-transaction"},"Broadcast Transaction")," sections\nfrom earlier."),(0,r.kt)("h3",{id:"putting-it-all-together-1"},"Putting it all together"),(0,r.kt)("p",null,"Your code should look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Mint Series Constructor Tokens"',title:'"Mint',Series:!0,Constructor:!0,'Tokens"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.Event.SeriesPolicy\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{LvlType, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.utils.Encoding\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport quivr.models.VerificationKey\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\n// Replace with the desired location for your key file\nval keyFile = Paths.get(tutorialDir, "keyfile.json").toString\n// Replace with the desired location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n  inputLock <- walletStateApi.getLock("self", "default", 2)\n  inputAddress <- txBuilder.lockAddress(inputLock.get)\n  txos <- genusQueryApi.queryUtxo(inputAddress)\n  seriesPolicy = SeriesPolicy(\n    "Series Policy Label",\n    registrationUtxo = txos.filter(_.transactionOutput.value.value.typeIdentifier == LvlType).head.outputAddress\n  )\n  outputLock <- walletStateApi.getLock("self", "default", 3)\n  outputAddress <- txBuilder.lockAddress(outputLock.get)\n  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>\n    // Derive the verification key at path 1/1/3 (used in outputLock)\n    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 3)\n  }\n  _ <- walletStateApi.updateWalletState(\n    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),\n    outputAddress.toBase58(),\n    Some("ExtendedEd25519"),\n    Some(Encoding.encodeToBase58(outputVk.toByteArray)),\n    Indices(1, 1, 3)\n  )\n  tx <- txBuilder.buildSeriesMintingTransaction(\n    txos,\n    inputLock.get.getPredicate,\n    seriesPolicy,\n    5L,\n    outputAddress,\n    outputAddress,\n    1L\n  )\n} yield tx.toOption.get\n\nval provenTx = for {\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  tx <- unprovenTransaction\n  ctx = Context[IO](tx, 50, _ => None)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res.toOption.get\n\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  tx <- provenTx\n  _ <- bifrostQuery.broadcastTransaction(tx)\n} yield ()\n\nbroadcastTransaction.unsafeRunSync()\n\nval queryFunds = for {\n  // The tokens were sent to the address derived from (self, default, 3)\n  sigLock <- walletStateApi.getLock("self", "default", 3)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value =>\n  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"\n)\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,r.kt)("p",null,"After ensuring that some time has passed since minting the Group Constructor Tokens from Step 1 (15-20 seconds), try\nrunning the code. If all went well, you should see that you have 98 LVLs, 5 Group Constructor Token, and 5 Series\nConstructor token in your wallet, ready to be spent by you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"GroupType: 5\nLvlType$: 98\nSeriesType: 5\n")),(0,r.kt)("p",null,"Keep the same local node instance running."),(0,r.kt)("h2",{id:"step-3-mint-asset-tokens"},"Step 3: Mint Asset Tokens"),(0,r.kt)("p",null,"Now that we have Group and Series Constructor Tokens ready to spend, we can mint our Asset Tokens. Asset Tokens are minted\nusing an Asset Minting Statement. For the sake of brevity, this section will reference prior sections of this tutorial where\npossible. If you have not completed the prior sections, please do so before continuing."),(0,r.kt)("h3",{id:"query-genus-funds-2"},"Query Genus Funds"),(0,r.kt)("p",null,'From the previous section, our wallet should have 98 LVLs, 5 Group Constructor Tokens, and 5 Series Constructor Tokens\nencumbered by a 1-of-1 Signature Lock stored at (fellowship="self", template="default", nextInteraction=3). To obtain the\nfunds, we must query Genus for the UTXOs. This is very similar to the ',(0,r.kt)("a",{parentName:"p",href:"#query-genus-funds-1"},"previous section"),", however, we are using ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=3"),"\ninstead of ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=2"),"."),(0,r.kt)("h3",{id:"create-asset-minting-statement"},"Create Asset Minting Statement"),(0,r.kt)("p",null,"We need to create the Asset Minting Statement that will be used to mint the Asset Tokens. To see all fields of an\nAsset Minting Statement, see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Topl/tips/tree/main/TIP-0003#asset-minting-statement"},"TIP-0003"),"."),(0,r.kt)("p",null,"Similar to the Group and Series Policy, the Asset Minting Statement reference existing UTXOs. However, these UTXOs should not\ncontain LVLs. The field ",(0,r.kt)("inlineCode",{parentName:"p"},"groupTokenUtxo")," should reference a UTXO that contains the Group Constructor Tokens and the field\n",(0,r.kt)("inlineCode",{parentName:"p"},"seriesTokenUtxo")," should reference a UTXO that contains the Series Constructor Tokens. In this tutorial, we will use the\nUTXO that contains the 5 Group Constructor Tokens and the UTXO that contains the 5 Series Constructor Tokens, respectively.\nSince all of our UTXOs from the previous sections are encumbered by the same Lock Address, we will need to extract the TXOs\nwith the relevant constructor tokens."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"AssetMintingStatement(\n  txos.filter(_.transactionOutput.value.value.isGroup).head.outputAddress,\n  txos.filter(_.transactionOutput.value.value.isSeries).head.outputAddress,\n  BigInt(10)\n)\n")),(0,r.kt)("h3",{id:"generate-a-new-lock-address-2"},"Generate a New Lock Address"),(0,r.kt)("p",null,"Since we will create a new transaction, we need to generate a new Lock Address to encumber the transaction outputs. Mirroring\nthe ",(0,r.kt)("a",{parentName:"p",href:"#generate-a-new-lock-address"},"Group Constructor section")," and ",(0,r.kt)("a",{parentName:"p",href:"#generate-a-new-lock-address-1"},"Series Constructor section"),",\nwe will use the same lock address for both the minted asset tokens and the change."),(0,r.kt)("p",null,"This is very similar to the linked sections, however, we are using ",(0,r.kt)("inlineCode",{parentName:"p"},"nextInteraction=4"),". In other words, we are deriving\nthe verification key at path ",(0,r.kt)("inlineCode",{parentName:"p"},"1/1/4")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"self/default/4"),")."),(0,r.kt)("h3",{id:"create-transaction-2"},"Create Transaction"),(0,r.kt)("p",null,"Using everything we generated in this section, we can finally build the transaction using the Transaction Builder API.\nWe will be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"buildAssetMintingTransaction")," function.\nRead ",(0,r.kt)("a",{parentName:"p",href:"../../reference/transactions/minting#mint-asset-tokens"},"Mint Asset Tokens")," for more information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).buildAssetMintingTransaction(\n  mintingStatement, // The Asset Minting Statement we created from "Create Asset Minting Statement"\n  txos,  // The UTXOs we queried from "Query Genus Funds"\n  Map(inputAddr -> inputLock.getPredicate), // A mapping containing the existing lock we retrieved from "Query Genus Funds"\n  1L, // An arbitrary fee amount\n  mintedAddress, // The lock address we created from "Generate a New Lock Address"\n  changeAddress, // The lock address we created from "Generate a New Lock Address"\n)\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Unlike previous sections, this function takes in a mapping of input addresses to their respective locks. This is because\nthe Group Constructor Tokens, Series Constructor Tokens, and LVLs (for fee) could potentially all be encumbered by different\nlocks. In this tutorial, we are using the same lock for all three, but this is not a requirement.")),(0,r.kt)("h3",{id:"prove-and-broadcast-transaction-1"},"Prove and Broadcast Transaction"),(0,r.kt)("p",null,"Mirroring the previous section, after we build the transaction, we need to prove, validate, and broadcast the transaction.\nThis is identical to the ",(0,r.kt)("a",{parentName:"p",href:"#prove-transaction"},"Prove Transaction")," and ",(0,r.kt)("a",{parentName:"p",href:"#broadcast-transaction"},"Broadcast Transaction")," sections\nfrom earlier."),(0,r.kt)("h3",{id:"putting-it-all-together-2"},"Putting it all together"),(0,r.kt)("p",null,"At this point, your code should look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Mint Asset Tokens"',title:'"Mint',Asset:!0,'Tokens"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.models.box.AssetMintingStatement\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{bigIntAsInt128, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.utils.Encoding\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport quivr.models.VerificationKey\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\n// Replace with the desired location for your key file\nval keyFile = Paths.get(tutorialDir, "keyfile.json").toString\n// Replace with the desired location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n  inputLock <- walletStateApi.getLock("self", "default", 3)\n  inputAddress <- txBuilder.lockAddress(inputLock.get)\n  txos <- genusQueryApi.queryUtxo(inputAddress)\n  mintingStatement = AssetMintingStatement(\n    txos.filter(_.transactionOutput.value.value.isGroup).head.outputAddress,\n    txos.filter(_.transactionOutput.value.value.isSeries).head.outputAddress,\n    BigInt(10)\n  )\n  outputLock <- walletStateApi.getLock("self", "default", 4)\n  outputAddress <- txBuilder.lockAddress(outputLock.get)\n  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>\n    // Derive the verification key at path 1/1/4 (used in outputLock)\n    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 4)\n  }\n  _ <- walletStateApi.updateWalletState(\n    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),\n    outputAddress.toBase58(),\n    Some("ExtendedEd25519"),\n    Some(Encoding.encodeToBase58(outputVk.toByteArray)),\n    Indices(1, 1, 4)\n  )\n  tx <- txBuilder.buildAssetMintingTransaction(\n    mintingStatement,\n    txos,\n    Map(inputAddress -> inputLock.get.getPredicate),\n    1L,\n    outputAddress,\n    outputAddress\n  )\n} yield tx.toOption.get\n\nval provenTx = for {\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  tx <- unprovenTransaction\n  ctx = Context[IO](tx, 50, _ => None)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res.toOption.get\n\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  tx <- provenTx\n  _ <- bifrostQuery.broadcastTransaction(tx)\n} yield ()\n\nbroadcastTransaction.unsafeRunSync()\n\nval queryFunds = for {\n  // The tokens were sent to the address derived from (self, default, 4)\n  sigLock <- walletStateApi.getLock("self", "default", 4)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value =>\n  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"\n)\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,r.kt)("p",null,"After ensuring that some time has passed since minting the Series Constructor Tokens from Step 2 (15-20 seconds), try\nrunning the code. If all went well, you should see that you have 97 LVLs, 5 Group Constructor Token, 5 Series Constructor\nToken, and 10 Asset token in your wallet, ready to be spent by you."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"SeriesType: 5\nGroupType: 5\nLvlType$: 97\nAssetType: 10\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The above output will differ if you configured your Series Policy differently.")),(0,r.kt)("p",null,"For example, if you configured your Series Policy's ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenSupply")," to be 5, you should see that you have 3 Series\nConstructor Tokens remaining instead of 5. This is because setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenSupply")," field indicates that the Series\nConstructor Tokens have a limited supply. In other words, a Series Constructor Token is burned for every 5 Asset Tokens\nminted, leaving 3 remaining as change. For more information on the possible configurations of a Series Policy, see\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Topl/tips/tree/main/TIP-0003"},"TIP-0003"),"."))}d.isMDXComponent=!0}}]);