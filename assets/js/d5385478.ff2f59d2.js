"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[440],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,m=p["".concat(s,".").concat(h)]||p[h]||u[h]||l;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:i,r[1]=o;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5149:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const l={sidebar_position:2,title:"Transfer Tokens",description:"Transfer tokens from one wallet to another"},r=void 0,o={unversionedId:"tutorials/tutorials/simple-transfer",id:"tutorials/tutorials/simple-transfer",title:"Transfer Tokens",description:"Transfer tokens from one wallet to another",source:"@site/docs/tutorials/tutorials/simple-transfer.md",sourceDirName:"tutorials/tutorials",slug:"/tutorials/tutorials/simple-transfer",permalink:"/BramblSc/docs/current/tutorials/tutorials/simple-transfer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Transfer Tokens",description:"Transfer tokens from one wallet to another"},sidebar:"tutorialsSidebar",previous:{title:"Load Wallet with Funds",permalink:"/BramblSc/docs/current/tutorials/tutorials/obtain-funds"},next:{title:"Mint Custom Asset",permalink:"/BramblSc/docs/current/tutorials/tutorials/mint-asset"}},s={},c=[{value:"Use Case",id:"use-case",level:2},{value:"Set-Up",id:"set-up",level:2},{value:"Step 1: Recipient",id:"step-1-recipient",level:2},{value:"Create and Initialize the Recipient&#39;s Wallet",id:"create-and-initialize-the-recipients-wallet",level:3},{value:"Generates a New Lock Address to Receive Tokens",id:"generates-a-new-lock-address-to-receive-tokens",level:3},{value:"Putting it all together",id:"putting-it-all-together",level:3},{value:"Step 2: Sender",id:"step-2-sender",level:2},{value:"Create Transaction",id:"create-transaction",level:3},{value:"Prove Transaction",id:"prove-transaction",level:3},{value:"Broadcast Transaction",id:"broadcast-transaction",level:3},{value:"Putting it all together",id:"putting-it-all-together-1",level:3},{value:"Optional Steps: Check Balances",id:"optional-steps-check-balances",level:2},{value:"Recipient Checks Balance",id:"recipient-checks-balance",level:3},{value:"Sender Checks Balance",id:"sender-checks-balance",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"use-case"},"Use Case"),(0,i.kt)("p",null,"To send 10 LVLs from an existing wallet to a new wallet."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Objectives:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create a new wallet and lock address (the recipient's wallet)"),(0,i.kt)("li",{parentName:"ul"},"Share a LockAddress with another wallet by Encoding it as a Base58 string"),(0,i.kt)("li",{parentName:"ul"},"Use the keys and state from an existing wallet (the sender's wallet)"),(0,i.kt)("li",{parentName:"ul"},"Create a transaction to ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"transfer an amount of funds from one wallet to another"),(0,i.kt)("li",{parentName:"ul"},"transfer the remaining funds back to the original wallet in a new LockAddress"))),(0,i.kt)("li",{parentName:"ul"},"Check the balance of a LockAddress")),(0,i.kt)("h2",{id:"set-up"},"Set-Up"),(0,i.kt)("p",null,"In this tutorial, we have 2 users, each with their own wallet. The first is the Sender, the second is the Recipient."),(0,i.kt)("p",null,'Throughout this tutorial, we will be alternating between the Sender and the Recipient\'s Point-of-View. To distinguish\nbetween the two, each section will be marked with either "Sender" or "Recipient". We will also keep all the\ngenerated files (key file, wallet file, etc.) in separate folders for each user.'),(0,i.kt)("p",null,"To follow along with this tutorial, you will need to initialize and fund the Sender's wallet with 100 LVLs. "),(0,i.kt)("p",null,"If you were following the instructions in the ",(0,i.kt)("a",{parentName:"p",href:"./obtain-funds"},"Load Wallet with Funds")," tutorial, the code to set up the\nSenders wallet should look something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",100:!0,className:"language-scala",metastring:'title="Initializing the Sender\'s Wallet and Funding it with 100 LVLs"',title:'"Initializing',the:!0,"Sender's":!0,Wallet:!0,and:!0,Funding:!0,it:!0,with:!0,'LVLs"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.{Datum, Event}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{LvlType, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps, int128AsBigInt}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your *Sender* tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial", "sender").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n  val filePath = Paths.get(tutorialDir, fileName).toString\n  new File(filePath).delete() // Clear the file if it already exists\n  filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, mainKeyPair.toOption.get)\n} yield mainKeyPair\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n  _ <- initializeWallet\n  heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)\n  heightAddress <- txBuilder.lockAddress(heightLock.get)\n  txos <- genusQueryApi.queryUtxo(heightAddress)\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  tx <- txBuilder.buildTransferAmountTransaction(\n    LvlType,\n    txos,\n    heightLock.get.getPredicate,\n    100L,\n    sigAddress,\n    heightAddress,\n    1L\n  )\n} yield tx.toOption.get\n\nval proveAndValidateResult = for {\n  tx <- unprovenTransaction\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  ctx = Context[IO](tx, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  provenTx <- proveAndValidateResult\n  txId <- bifrostQuery.broadcastTransaction(provenTx.toOption.get)\n} yield txId\n\nbroadcastTransaction.unsafeRunSync()\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\n// optionally view your funds\nval queryFunds = for {\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,i.kt)("p",null,"After running that file, you should see that the Sender's wallet has been initialized with 100 LVLs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"LvlType: 100\n")),(0,i.kt)("p",null,"Keep the same local node instance running. We will be using it for the rest of this tutorial."),(0,i.kt)("h2",{id:"step-1-recipient"},"Step 1: Recipient"),(0,i.kt)("p",null,"Before we can send tokens to the recipient, the recipient needs to have a wallet and a LockAddress that they have ownership of. "),(0,i.kt)("h3",{id:"create-and-initialize-the-recipients-wallet"},"Create and Initialize the Recipient's Wallet"),(0,i.kt)("p",null,"Initializing the recipient's wallet is similar to initializing the sender's wallet. For more details you can read\n",(0,i.kt)("a",{parentName:"p",href:"./obtain-funds#step-1-create-and-initialize-a-wallet"},"Create and Initialize a Wallet")," in the Load Wallet with Funds tutorial."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create the Topl main key for the Recipient's wallet. For more details see the\n",(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#create-the-wallets-topl-main-key"},"Create the Wallet's Topl Main Key"),"'s section in a previous tutorial."),(0,i.kt)("li",{parentName:"ol"},"Using the main key from the previous step, initialize the Recipient's Wallet State. For more details see the\n",(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#initialize-the-wallet-state"},"Initialize the Wallet State")," section in a previous tutorial.")),(0,i.kt)("h3",{id:"generates-a-new-lock-address-to-receive-tokens"},"Generates a New Lock Address to Receive Tokens"),(0,i.kt)("p",null,"After the recipient's wallet has been initialized, we can generate the LockAddress for the recipient to receive the 10 LVLs.\nFor this tutorial, we will generate a LockAddress for a 1-of-1 Digital Signature Lock."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Generate the 1-of-1 Signature lock and LockAddress for the recipient. For more details see the\n",(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#generate-a-new-lock-address-to-receive-tokens"},"Generate a New Lock Address to Receive Tokens")," section in\na previous tutorial."),(0,i.kt)("li",{parentName:"ol"},"This LockAddress must be shared to the Sender. To support this, the Recipient will encode their LockAddress into a Base58 format.\nSee ",(0,i.kt)("a",{parentName:"li",href:"../../reference/locks/share-lock-addr"},"Share a LockAddress"),". ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"val base58Addr = encodeAddress(lockAddress)\n")))),(0,i.kt)("h3",{id:"putting-it-all-together"},"Putting it all together"),(0,i.kt)("p",null,"At this point, you should have code to create a new wallet and lock address for the recipient. The code should look similar to this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Initializing the Recipient\'s Wallet and Generating a LockAddress"',title:'"Initializing',the:!0,"Recipient's":!0,Wallet:!0,and:!0,Generating:!0,a:!0,'LockAddress"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.codecs.AddressCodecs.encodeAddress\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your *Recipient* tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial", "recipient").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n  val filePath = Paths.get(tutorialDir, fileName).toString\n  new File(filePath).delete() // Clear the file if it already exists\n  filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, mainKeyPair.toOption.get)\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  lockAddress <- TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).lockAddress(sigLock.get)\n} yield encodeAddress(lockAddress)\n\ninitializeWallet.unsafeRunSync()\n')),(0,i.kt)("p",null,"After running that file, you should see the Recipient's LockAddress:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"val res1: String = ptetP7jshHVVBsmyLd5ugb9mVSehmtFdZHYQZqG3zaFtWSfiX79kYt9obJea\n")),(0,i.kt)("p",null,"It is important to note that your LockAddress will be different from the one shown above. Everytime the code is run, a new\nTopl main key is generated, thus resulting in a new LockAddress. "),(0,i.kt)("h2",{id:"step-2-sender"},"Step 2: Sender"),(0,i.kt)("p",null,"Once the Sender has the Recipient's LockAddress, they can send begin the process of sending the 10 LVLs to the Recipient."),(0,i.kt)("h3",{id:"create-transaction"},"Create Transaction"),(0,i.kt)("p",null,"The Sender must build an unproven transaction to send 10 LVLs to the Recipient's LockAddress. Any change (excess LVLs) from the\ntransaction should go to a new LockAddress that the Sender owns. For this tutorial, we will generate a LockAddress for a 1-of-1\nDigital Signature Lock for the change."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Building a transaction requires specifying a LockAddress of the recipient. The Recipient shared their address as a base58 encoded\nstring. The first step is to decode this lock address. See ",(0,i.kt)("a",{parentName:"li",href:"../../reference/locks/share-lock-addr"},"Share a LockAddress"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val recipientAddr = decodeAddress("ptetP7jshHVVBsmyLd5ugb9mVSehmtFdZHYQZqG3zaFtWSfiX79kYt9obJea")\n'))),(0,i.kt)("li",{parentName:"ol"},'From the Sender\'s initialization (in the Set-Up section), the Sender loaded funds to their wallet, encumbered by a 1-of-1 Signature Lock\nstored at (fellowship="self", template="default", nextInteraction=1). To obtain the funds, we must query Genus for the UTXOs. This is similar\nto the section ',(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#query-genesis-funds"},"Query Genesis Funds")," in the Obtain Funds tutorial, however, the parameters for\n",(0,i.kt)("inlineCode",{parentName:"li"},"getLock")," in the first step is different.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'inputLock <- walletStateApi.getLock("self", "default", 1)\n'))),(0,i.kt)("li",{parentName:"ol"},"Since the Sender owns 100 LVLs but is only sending 10 to the Recipient, we must create a new LockAddress for the change.\nFor this tutorial, we will generate a LockAddress for a 1-of-1 Digital Signature Lock for the change. This is very similar\nto the ",(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#generate-a-new-lock-address-to-receive-tokens"},"Generate a New Lock Address to Receive Tokens")," section in\na previous tutorial, however, we are using ",(0,i.kt)("inlineCode",{parentName:"li"},"nextInteraction=2")," for step 1 (to prevent address re-use).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'changeLock <- walletStateApi.getLock("self", "default", 2)\n'))),(0,i.kt)("li",{parentName:"ol"},"Since we are creating a new LockAddress for the change (that we want the Sender to be able to spend from in the future),\nwe must update the Wallet State with information to unlock the lock. We did not have to do this step in the set-up or previous\nsections since Wallet State Initialization populates the information for the initial Signature Lock at indices (1, 1, 1). ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'walletStateApi.updateWalletState(\n  changePredicate, // The predicate contained in changeLock\n  changeAddress, // The LockAddress of the changeLock\n  Some("ExtendedEd25519"), // The signing routine of the Signature Lock\n  changeVk, // The verification key of the Signature Lock. This is the same as deriving the main key with indices (1, 1, 2)\n  Indices(1,1,2) // The indices of the Signature Lock\n)\n'))),(0,i.kt)("li",{parentName:"ol"},"Using everything we generated in this section, we can finally build the transaction using the Transaction Builder API. This mirrors\nthe ",(0,i.kt)("a",{parentName:"li",href:"./obtain-funds#build-the-transaction"},"Build the Transaction")," section in the Obtain Funds tutorial.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).buildTransferAmountTransaction(\n LvlType, // We are transferring LVLs\n txos,  // The UTXOs we queried from step 2\n inputLock.getPredicate, // The existing lock we retrieved as part of step 2 \n 10L, // The amount of LVLs we want to transfer to the recipient\n recipientAddr, // The decoded LockAddress of the recipient from step 1\n changeAddress, // The LockAddress of the changeLock from step 3\n 1L // An arbitrary fee amount\n)\n")))),(0,i.kt)("h3",{id:"prove-transaction"},"Prove Transaction"),(0,i.kt)("p",null,"Once we have built the unproven transaction, we must prove (and then validate) it. This is similar to the\n",(0,i.kt)("a",{parentName:"p",href:"./obtain-funds#step-3-prove-transaction"},"Prove Transaction")," section in the Obtain Funds tutorial, with a couple differences."),(0,i.kt)("p",null,"We must load the main key from the Sender's existing wallet to intialize the Credentialler with.\nSee ",(0,i.kt)("a",{parentName:"p",href:"../../reference/wallets/usage#load-and-decrypt-a-topl-main-key-pair"},"Load and Decrypt a Topl Main Key Pair"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n')),(0,i.kt)("p",null,"We can also simplify the Context used from step 2 in the Obtain Funds tutorial since we are not using a Height Lock:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"ctx = Context[IO](unprovenTransaction, 50, _ => None)\n")),(0,i.kt)("h3",{id:"broadcast-transaction"},"Broadcast Transaction"),(0,i.kt)("p",null,"Once the transaction is proven and validated, the Sender can broadcast the transaction to the network. This is exactly\nidentical to the ",(0,i.kt)("a",{parentName:"p",href:"./obtain-funds#step-4-broadcast-transaction"},"Broadcast Transaction")," section in the Obtain Funds tutorial."),(0,i.kt)("h3",{id:"putting-it-all-together-1"},"Putting it all together"),(0,i.kt)("p",null,"At this point, you should have code to create and submit a transaction to send 10 LVLs from the Sender's wallet to the\nRecipient's LockAddress. The code should look similar to this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",10:!0,className:"language-scala",metastring:'title="Sender submits TX to send 10 LVLs to Recipient"',title:'"Sender',submits:!0,TX:!0,to:!0,send:!0,LVLs:!0,'Recipient"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.LvlType\nimport co.topl.brambl.utils.Encoding\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport quivr.models.VerificationKey\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the existing location for your *Sender* tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial", "sender").toString\n// Replace with the existing location for your key file\nval keyFile = Paths.get(tutorialDir, "keyfile.json").toString\n// Replace with the existing location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\n// Replace the string with your Recipient\'s Base58 lock address\nval recipientAddr = decodeAddress("ptetP7jshHVVBsmyLd5ugb9mVSehmtFdZHYQZqG3zaFtWSfiX79kYt9obJea").toOption.get\n\nval unprovenTransaction = for {\n  inputLock <- walletStateApi.getLock("self", "default", 1)\n  inputAddress <- txBuilder.lockAddress(inputLock.get)\n  txos <- genusQueryApi.queryUtxo(inputAddress)\n  changeLock <- walletStateApi.getLock("self", "default", 2)\n  changeAddress <- txBuilder.lockAddress(changeLock.get)\n  selfDefaultVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) map { vk =>\n    VerificationKey.parseFrom(\n      Encoding.decodeFromBase58(vk).toOption.get\n    )\n  }\n  changeVk <- walletApi.deriveChildVerificationKey(selfDefaultVk, 2)\n  _ <- walletStateApi.updateWalletState(\n    Encoding.encodeToBase58(changeLock.get.getPredicate.toByteArray),\n    changeAddress.toBase58(),\n    Some("ExtendedEd25519"),\n    Some(Encoding.encodeToBase58(changeVk.toByteArray)),\n    Indices(1, 1, 2)\n  )\n  tx <- txBuilder.buildTransferAmountTransaction(\n    LvlType,\n    txos,\n    inputLock.get.getPredicate,\n    10L,\n    recipientAddr,\n    changeAddress,\n    1L\n  )\n} yield tx.toOption.get\n\nval provenTx = for {\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  tx <- unprovenTransaction\n  ctx = Context[IO](tx, 50, _ => None)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res.toOption.get\n\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  tx <- provenTx\n  _ <- bifrostQuery.broadcastTransaction(tx)\n} yield "Transaction Submitted"\n\nbroadcastTransaction.unsafeRunSync()\n')),(0,i.kt)("p",null,"After running that file, you should see a message that the transaction was submitted to the network. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"val res0: String = Transaction Submitted\n")),(0,i.kt)("h2",{id:"optional-steps-check-balances"},"Optional Steps: Check Balances"),(0,i.kt)("p",null,"After waiting a short period of time, the Recipient and Sender can check their balances to see if the transaction was\nprocessed successfully. "),(0,i.kt)("h3",{id:"recipient-checks-balance"},"Recipient Checks Balance"),(0,i.kt)("p",null,"The following code shows an example of the recipient checking their balance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Recipient checks balance"',title:'"Recipient',checks:!0,'balance"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the existing location for your *Recipient* tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial", "recipient").toString\n// Replace with the existing location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval queryFunds = for {\n  // The sender sent funds to the address derived from (self, default, 1)\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,i.kt)("p",null,"If all goes well, the recipient should see a balance of 10 LVLs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"LvlType: 10\n")),(0,i.kt)("h3",{id:"sender-checks-balance"},"Sender Checks Balance"),(0,i.kt)("p",null,"The following code shows an example of the sender checking their balance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="Sender checks balance"',title:'"Sender',checks:!0,'balance"':!0},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the existing location for your *Sender* tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial", "sender").toString\n// Replace with the existing location of for your wallet state DB file\nval walletDb = Paths.get(tutorialDir, "wallet.db").toString\nval conn = WalletStateResource.walletResource(walletDb)\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval queryFunds = for {\n  // The change went to the address derived from (self, default, 2)\n  sigLock <- walletStateApi.getLock("self", "default", 2)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,i.kt)("p",null,"If all goes well, the sender should see a balance of 89 LVLs in their change address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="output"',title:'"output"'},"LvlType: 89\n")),(0,i.kt)("p",null,"The 89 LVLs is the result of the 100 LVLs the sender had before the transaction minus the 10 LVLs they sent to the recipient\nminus the 1 LVL fee they paid to the network."))}u.isMDXComponent=!0}}]);