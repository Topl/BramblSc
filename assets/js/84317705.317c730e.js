"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[407],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(p,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(f,l(l({ref:t},s),{},{components:n})):a.createElement(f,l({ref:t},s))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[d]="string"==typeof e?e:r,l[1]=i;for(var c=2;c<o;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7884:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),r=n(9960),o=n(6550),l=n(8084);function i(e){let{children:t,path:n}=e;var i=function(){const{pathname:e}=(0,o.TH)(),{versions:t}=(0,l.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:n}=t;return e.startsWith(n)})).name||"current"}();return a.createElement(r.Z,{to:`/scaladoc/${i}/${n}`,target:"_blank"},t)}},7203:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var a=n(7462),r=(n(7294),n(3905)),o=n(7884);const l={sidebar_position:6,title:"Prove a Transaction",description:"Prove a transaction."},i=void 0,p={unversionedId:"reference/prove",id:"reference/prove",title:"Prove a Transaction",description:"Prove a transaction.",source:"@site/docs/reference/prove.mdx",sourceDirName:"reference",slug:"/reference/prove",permalink:"/BramblSc/docs/current/reference/prove",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Prove a Transaction",description:"Prove a transaction."},sidebar:"referenceSidebar",previous:{title:"Transfer Tokens",permalink:"/BramblSc/docs/current/reference/transactions/transfer"},next:{title:"Scaladoc",permalink:"/BramblSc/docs/current/reference/scaladoc"}},c={},s=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Prove",id:"prove",level:2},{value:"Example",id:"example",level:2}],d={toc:s},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Before you can broadcast a ",(0,r.kt)("a",{parentName:"p",href:"./transactions"},"newly created transaction")," to the blockchain, you must prove that you have the authority to\nspend the input tokens. You can accomplish this using the SDK's Credentialler."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"The following requires access to a Credentialler instance. You can initialize one using the following snippet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val credentialler = CredentiallerInterpreter.make[F](walletApi, walletStateApi, mainKey)\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," is a type parameter bound to a context parameter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad[F]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"walletApi")," is an instance of\na ",(0,r.kt)("a",{parentName:"p",href:"./wallets#prerequisites"},"Wallet Api"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"walletStateApi")," is an initialized instance of\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"WalletStateAlgebra")),",\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"mainKey")," is your ExtendedEd25519 Topl main key pair. See the ",(0,r.kt)("inlineCode",{parentName:"p"},"make"),"\nfunction's ",(0,r.kt)(o.Z,{path:"co/topl/brambl/wallet/CredentiallerInterpreter$.html#make[F[_]](WalletApi[F],WalletStateAlgebra[F],KeyPair)(Monad[F]):Credentialler[F]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"signature")),".\nFor example, if you are using Cats Effect ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," and the default implementation of\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/servicekit/index.html",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"ServiceKit")),", you can initialize\na Credentialler as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport co.topl.brambl.servicekit.WalletStateResource\nimport co.topl.crypto.signing.ExtendedEd25519\nimport co.topl.brambl.syntax.cryptoToPbKeyPair\n\n// Replace with the location of your wallet state file\nval DB_FILE = "wallet.db"\nval walletConnection = WalletStateResource.walletResource(DB_FILE)\n\nval walletApi = WalletApi.make[IO](WalletKeyApi.make())\nval walletStateApi = WalletStateApi.make[IO](walletConnection, walletApi)\n// Some mock key pair. Do not use. Replace with your Topl main key pair.\nval mainKey = (new ExtendedEd25519).deriveKeyPairFromSeed(Array.fill(96)(0: Byte))\n\n// Credentialler initialization starts:\nval credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n')),(0,r.kt)("h2",{id:"prove"},"Prove"),(0,r.kt)("p",null,"You can prove a transaction using\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/wallet/Credentialler.html#prove(IoTransaction):F[IoTransaction]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"prove")),"\nfunction of a Credentialler instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def prove(\n  unprovenTx: IoTransaction\n): F[IoTransaction]\n")),(0,r.kt)("p",null,"This function takes in a transaction and proves every input by updating their attestations. Any existing proofs are persisted.\nThis is useful for partial proofs. For example, if an input is encumbered by an ",(0,r.kt)("inlineCode",{parentName:"p"},"And")," lock, a partial proof could be that\nonly one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"And")," lock's sub-propositions is proven. In this case, calling this function will add the proof for the\nsecond sub-proposition while leaving the first sub-proposition's proof intact."),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unprovenTx"),": The transaction to prove. As mentioned above, this transaction may already have some proofs. To obtain\na new transaction with no proofs, read ",(0,r.kt)("a",{parentName:"li",href:"./transactions"},"Build a Transaction"))),(0,r.kt)("p",null,"On success, this function returns the given transaction with updated proofs which can be broadcasted to the network.\nThis returned ",(0,r.kt)("inlineCode",{parentName:"p"},"IoTransaction")," has the same signable bytes as the original transaction. If any of the contained propositions\nare unable to be proven, their proofs will be left unchanged."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Proving a transaction does not guarantee that the transaction will be accepted by the network. The transaction may still be\nrejected if it is malformed or if it is not sufficiently proven. For this reason, it is recommended to use\nthe ",(0,r.kt)("a",{parentName:"p",href:"#prove-and-validate"},(0,r.kt)("inlineCode",{parentName:"a"},"proveAndValidate"))," function instead.")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"The following example shows how to prove a transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.builders.locks.LockTemplate\nimport co.topl.brambl.builders.locks.PropositionTemplate.HeightTemplate\nimport co.topl.brambl.builders.locks.LockTemplate.PredicateTemplate\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.syntax.{UnknownType, valueToTypeIdentifierSyntaxOps}\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.servicekit.WalletStateResource\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport co.topl.crypto.signing.ExtendedEd25519\nimport co.topl.brambl.syntax.cryptoToPbKeyPair\n\n// Replace with the location of your wallet state file\nval walletConnection = WalletStateResource.walletResource("wallet.db")\n\n// Some mock key pair. Do not use. Replace with your Topl main key pair.\nval mainKey = (new ExtendedEd25519).deriveKeyPairFromSeed(Array.fill(96)(0: Byte))\n\n// Mock address. Replace with recipient address.\nval toAddr = decodeAddress("ptetP7jshHTuV9bmPmtVLm6PtUzBMZ8iYRvAxvbGTJ5VgiEPHqCCnZ8MLLdi").toOption.get\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQuery = GenusQueryAlgebra.make[IO](channelResource)\nval predicateTemplate: LockTemplate[IO] = PredicateTemplate[IO](Seq(HeightTemplate("header", 1, Long.MaxValue)), 1)\nval walletApi = WalletApi.make[IO](WalletKeyApi.make())\nval walletStateApi = WalletStateApi.make[IO](walletConnection, walletApi)\nval credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n\nval tx = for {\n  fromLock <- predicateTemplate.build(List.empty).map(_.toOption.get)\n  fromAddr <- transactionBuilderApi.lockAddress(fromLock)\n  txos <- genusQuery.queryUtxo(fromAddr)\n  fromTxos = txos.filter(_.transactionOutput.value.value.typeIdentifier != UnknownType)\n  unprovenTx <- transactionBuilderApi.buildTransferAllTransaction(fromTxos, fromLock.getPredicate, toAddr, toAddr, 1L)\n  // Proving begins here:\n  provenTx <- credentialler.prove(unprovenTx.toOption.get)\n} yield provenTx\n\ntx.unsafeRunSync()\n')))}m.isMDXComponent=!0}}]);