"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[589],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var l=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,l,i=function(e,t){if(null==e)return{};var a,l,i={},n=Object.keys(e);for(l=0;l<n.length;l++)a=n[l],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(l=0;l<n.length;l++)a=n[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=l.createContext({}),p=function(e){var t=l.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return l.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},u=l.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=p(a),u=i,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||n;return a?l.createElement(h,o(o({ref:t},c),{},{components:a})):l.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,o=new Array(n);o[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<n;p++)o[p]=a[p];return l.createElement.apply(null,o)}return l.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7884:(e,t,a)=>{a.d(t,{Z:()=>r});var l=a(7294),i=a(9960),n=a(6550),o=a(8084);function r(e){let{children:t,path:a}=e;var r=function(){const{pathname:e}=(0,n.TH)(),{versions:t}=(0,o.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:a}=t;return e.startsWith(a)})).name||"current"}();return l.createElement(i.Z,{to:`/scaladoc/${r}/${a}`,target:"_blank"},t)}},766:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var l=a(7462),i=(a(7294),a(3905)),n=a(7884);const o={sidebar_position:3,title:"Wallet State"},r=void 0,s={unversionedId:"reference/wallet-state",id:"reference/wallet-state",title:"Wallet State",description:"The wallet state keeps track of the child key pairs that have already been used to generate lock addresses. It also stores",source:"@site/docs/reference/wallet-state.mdx",sourceDirName:"reference",slug:"/reference/wallet-state",permalink:"/BramblSc/docs/current/reference/wallet-state",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Wallet State"},sidebar:"referenceSidebar",previous:{title:"Usage",permalink:"/BramblSc/docs/current/reference/wallets/usage"},next:{title:"RPC",permalink:"/BramblSc/docs/current/reference/rpc"}},p={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Initialize Wallet State",id:"initialize-wallet-state",level:2},{value:"Example",id:"example",level:3},{value:"Update Wallet State",id:"update-wallet-state",level:2},{value:"Example",id:"example-1",level:3},{value:"Add Digest Preimage",id:"add-digest-preimage",level:2},{value:"Example",id:"example-2",level:3}],d={toc:c},m="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,l.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The wallet state keeps track of the child key pairs that have already been used to generate lock addresses. It also stores\nthe necessary information to prove the ownership of the lock addresses. Keeping an up-to-date wallet state is crucial for\nproving your transactions."),(0,i.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"Managing your Wallet State starts requires creating an instance of\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"WalletStateAlgebra")),".\nThe SDK provides a default implementation within the ",(0,i.kt)("a",{parentName:"p",href:"../service-kit/big-picture"},"Service Kit"),". This default\nimplementation uses SQLite as a database to store the wallet state. If using the provided default implementation, you can\ninitialize an instance as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.io.File\n\n// Replace with the desired location for your wallet database file\nval walletDbFile = new File(System.getProperty("user.home"), "wallet.db").getCanonicalPath\n\nval walletApi = WalletApi.make(WalletKeyApi.make[IO]())\nval walletDbConnection = WalletStateResource.walletResource(walletDbFile)\n// highlight-next-line\nval walletStateApi = WalletStateApi.make[IO](walletDbConnection, walletApi)\n')),(0,i.kt)("p",null,"In the above example, we are using the provided default implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletApi")," and a connection to a file path\nto store the wallet state. If this is your first time using the wallet state, the file will be created. If you already\nhave a wallet state, the file path should point to the existing file."),(0,i.kt)("h2",{id:"initialize-wallet-state"},"Initialize Wallet State"),(0,i.kt)("p",null,"When creating a wallet for the first time, you must initialize its state. This can be done by calling the\nfunction ",(0,i.kt)(n.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html#initWalletState(Int,Int,VerificationKey):F[Unit]",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"initWalletState")),"\nin a Wallet State instance. Read more about state initialization in ",(0,i.kt)("a",{parentName:"p",href:"../service-kit/usage#creating-a-vault-and-a-wallet-database"},"Creating a Vault and a Wallet Database"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def initWalletState(networkId: Int, ledgerId: Int, vk: VerificationKey): F[Unit]\n")),(0,i.kt)("p",null,"This function initializes the original state of a newly created wallet. In the provided default implementation, this\nincludes creating the database tables and inserting the first fellowships, templates, and child key pair."),(0,i.kt)("p",null,"The parameters are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"networkId"),": The ID of the network that the wallet is being initialized for. This ID is used to generate the\ninitial lock addresses. The possible values are ",(0,i.kt)("inlineCode",{parentName:"li"},"MAIN_NETWORK_ID"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"PRIVATE_NETWORK_ID"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"TEST_NETWORK_ID")," found in the\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/constants/NetworkConstants$.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"NetworkConstants"))," object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ledgerId"),": The ID of the ledger that the wallet is being initialized for. This ID is used to generate the initial lock\naddresses. The only possible value is ",(0,i.kt)("inlineCode",{parentName:"li"},"MAIN_LEDGER_ID")," which can be found in the\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/constants/NetworkConstants$.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"NetworkConstants"))," object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"vk"),': The parent verification key (x, y) associated to the "self" fellowship and "default" template. Most commonly, this\nwill be the verification key derived from the (x=1, y=1) path of the wallet\'s Main Key Pair. This verification key is used\nto initialize the first fellowships, templates, and child key pair in the wallet state.')),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,"The following snippet is an example of initializing a wallet state for a new wallet using Cats Effect ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," and the default\nimplementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletKeyApi")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletStateApi")," provided by\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/servicekit/index.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"ServiceKit")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.io.File\n\n// Replace with the desired location for your wallet database file\nval walletDbFile = new File(System.getProperty("user.home"), "wallet.db").getCanonicalPath\n// Replace with the desired password for your wallet Key File\nval password = "password".getBytes\n\nval walletApi = WalletApi.make(WalletKeyApi.make[IO]())\nval walletDbConnection = WalletStateResource.walletResource(walletDbFile)\nval walletStateApi = WalletStateApi.make[IO](walletDbConnection, walletApi)\n\nval initializeWallet = for {\n  wallet <- walletApi.createNewWallet(password).map(_.fold(throw _, identity))\n  mainKey <- walletApi.extractMainKey(wallet.mainKeyVaultStore, password).map(_.fold(throw _, identity))\n  xyKey <- walletApi.deriveChildKeysPartial(mainKey, 1, 1)\n  // highlight-next-line\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, xyKey.vk)\n} yield ()\n\ninitializeWallet.unsafeRunSync()\n')),(0,i.kt)("h2",{id:"update-wallet-state"},"Update Wallet State"),(0,i.kt)("p",null,"It is important to update the wallet state everytime that you create a new lock associated to indices in your wallet.\nThe indices contain 3 integers (x, y, z) which represent a fellowship, template, and interaction respectively. This triple\nis associated to a lock; storing information associated to this lock will ensure that the lock can be proven and allowing\nthe funds to be spent. The wallet state can be updated by calling the\nfunction ",(0,i.kt)(n.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html#updateWalletState(String,String,Option[String],Option[String],Indices):F[Unit]",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"updateWalletState"))," in a Wallet State instance. Read more about state updating\nin ",(0,i.kt)("a",{parentName:"p",href:"../service-kit/usage#updating-the-wallet-database"},"Updating the Wallet Database"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def updateWalletState(\n  lockPredicate: String,\n  lockAddress:   String,\n  routine:       Option[String],\n  vk:            Option[String],\n  indices:       Indices\n): F[Unit]\n")),(0,i.kt)("p",null,"This function updates the state of the wallet with the information to prove a lock that is associated to the given indices.\nThis information includes the indices, the lock predicate and lock address of the lock that was generated, and optionally,\nthe signing routine and child verification key used if the lock included a Signature Proposition."),(0,i.kt)("p",null,"The parameters are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lockPredicate"),": The predicate of the lock that was generated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lockAddress"),": The address of the lock that was generated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"routine"),": If the lock contains a Signature Proposition for the user's child key derived at ",(0,i.kt)("inlineCode",{parentName:"li"},"indices"),", the signing routine used to generate the signature."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"vk"),": If the lock contains a Signature Proposition for the user's child key derived at ",(0,i.kt)("inlineCode",{parentName:"li"},"indices"),", the verification key\ncontained within this Signature Proposition. This verification key is also the verification key of the child key pair at ",(0,i.kt)("inlineCode",{parentName:"li"},"indices"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"indices"),": The indices (x, y, z) of the wallet state entry we are updating for.")),(0,i.kt)("h3",{id:"example-1"},"Example"),(0,i.kt)("p",null,"The following snippet is an example of updating a wallet state for a new lock associated with Indices using Cats Effect\n",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," and the default implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletKeyApi")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletStateApi")," provided by\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/servicekit/index.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"ServiceKit")),". In this example, we\nassume that the wallet state has already been initialized to ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.db"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport cats.implicits.toTraverseOps\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.models.Indices\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.utils.Encoding\nimport co.topl.brambl.wallet.WalletApi\nimport quivr.models.VerificationKey\n\nimport java.io.File\n\n// Replace with the location of your existing wallet database file\nval walletDbFile = new File(System.getProperty("user.home"), "wallet.db").getCanonicalPath\n\nval walletApi = WalletApi.make(WalletKeyApi.make[IO]())\nval walletDbConnection = WalletStateResource.walletResource(walletDbFile)\nval walletStateApi = WalletStateApi.make[IO](walletDbConnection, walletApi)\n\nval updateWallet = for {\n  // The (x, y, z) indices to update the wallet state at\n  indices <- IO.pure(Indices(1, 1, 2))\n  // The lock at the (x, y, z) indices. "self" and "default" were initialized to be at (x=1,y=1) per initWalletState\n  lock <- walletStateApi.getLock("self", "default", indices.z).map(_.get)\n  // lockAddress of the lock\n  lockAddress <- TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).lockAddress(lock).map(_.toBase58())\n  // predicate of the lock\n  lockPredicate = Encoding.encodeToBase58Check(lock.getPredicate.toByteArray)\n  // Parent verification key with derivation path (x=1,y=1)\n  parentVk <- walletStateApi.getEntityVks("self", "default")\n    .map(_.sequence.head.map(pVk => VerificationKey.parseFrom(Encoding.decodeFromBase58(pVk).toOption.get)))\n  // child verification key with derivation path (1, 1, 2)\n  vk <- parentVk.map(pVk => walletApi.deriveChildVerificationKey(pVk, indices.z)\n    .map(cVk => Encoding.encodeToBase58(cVk.toByteArray))).sequence\n  // highlight-next-line\n  _ <- walletStateApi.updateWalletState(lockPredicate, lockAddress, Some("ExtendedEd25519"), vk, indices)\n} yield ()\n\nupdateWallet.unsafeRunSync()\n')),(0,i.kt)("h2",{id:"add-digest-preimage"},"Add Digest Preimage"),(0,i.kt)("p",null,"In order to prove any lock that contains a Digest Proposition, the user must provide the preimage of the digest. This\ncan be done by calling the\nfunction ",(0,i.kt)(n.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html#addPreimage(Preimage,Digest):F[Unit]",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"addPreimage")),"\nin a Wallet State instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def addPreimage(preimage: Preimage, digest: Proposition.Digest): F[Unit]\n")),(0,i.kt)("p",null,"This function adds a preimage to the wallet state. The preimage is associated with the given digest proposition. This preimage can\nthen be used to prove any lock that contains the given digest proposition."),(0,i.kt)("h3",{id:"example-2"},"Example"),(0,i.kt)("p",null,"The following snippet is an example of adding and retrieving a preimage to the wallet state using Cats Effect ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," and the default\nimplementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletKeyApi")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"WalletStateApi")," provided by the\nthe ",(0,i.kt)(n.Z,{path:"co/topl/brambl/servicekit/index.html",mdxType:"ScaladocLink"},(0,i.kt)("code",null,"ServiceKit")),". In this example, we\nassume that the wallet state has already been initialized to ",(0,i.kt)("inlineCode",{parentName:"p"},"wallet.db"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.wallet.WalletApi\nimport co.topl.crypto.hash.Blake2b256\nimport com.google.protobuf.ByteString\nimport quivr.models.{Digest, Preimage, Proposition}\n\nimport java.io.File\n\n// Replace with the location of your existing wallet database file\nval walletDbFile = new File(System.getProperty("user.home"), "wallet.db").getCanonicalPath\n\nval walletApi = WalletApi.make(WalletKeyApi.make[IO]())\nval walletDbConnection = WalletStateResource.walletResource(walletDbFile)\nval walletStateApi = WalletStateApi.make[IO](walletDbConnection, walletApi)\n\nval preimageInput = "Some message".getBytes\nval salt = "Some salt".getBytes\nval digestValue = ByteString.copyFrom((new Blake2b256).hash(preimageInput ++ salt))\n// Preimage\nval preimage = Preimage(ByteString.copyFrom(preimageInput), ByteString.copyFrom(salt))\n// Digest proposition\nval digest = Proposition.Digest("Blake2b256", Digest(digestValue))\n\nval addAndGetPreimage = for {\n  _ <- walletStateApi.addPreimage(preimage, digest)\n  fetchedPreimage <- walletStateApi.getPreimage(digest)\n} yield fetchedPreimage.get\n\naddAndGetPreimage.unsafeRunSync() == preimage\n')))}u.isMDXComponent=!0}}]);