"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[993],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),h=l,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||i;return a?n.createElement(m,r(r({ref:t},p),{},{components:a})):n.createElement(m,r({ref:t},p))}));function m(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:l,r[1]=o;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4957:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(7462),l=(a(7294),a(3905));const i={sidebar_position:1,title:"Load Wallet with Funds",description:"Populate a wallet with LVL tokens from your Local Node"},r=void 0,o={unversionedId:"tutorials/tutorials/obtain-funds",id:"tutorials/tutorials/obtain-funds",title:"Load Wallet with Funds",description:"Populate a wallet with LVL tokens from your Local Node",source:"@site/docs/tutorials/tutorials/obtain-funds.md",sourceDirName:"tutorials/tutorials",slug:"/tutorials/tutorials/obtain-funds",permalink:"/BramblSc/docs/current/tutorials/tutorials/obtain-funds",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Load Wallet with Funds",description:"Populate a wallet with LVL tokens from your Local Node"},sidebar:"tutorialsSidebar",previous:{title:"Tutorials",permalink:"/BramblSc/docs/current/tutorials/tutorials/"},next:{title:"Transfer Tokens",permalink:"/BramblSc/docs/current/tutorials/tutorials/simple-transfer"}},s={},c=[{value:"Use Case",id:"use-case",level:2},{value:"Set-Up",id:"set-up",level:2},{value:"Step 1: Create and Initialize a Wallet",id:"step-1-create-and-initialize-a-wallet",level:2},{value:"Create the Wallet&#39;s Topl Main Key",id:"create-the-wallets-topl-main-key",level:3},{value:"Initialize the Wallet State",id:"initialize-the-wallet-state",level:3},{value:"Breakpoint Check",id:"breakpoint-check",level:3},{value:"Step 2: Create Transaction",id:"step-2-create-transaction",level:2},{value:"Query Genesis Funds",id:"query-genesis-funds",level:3},{value:"Generate a New Lock Address to Receive Tokens",id:"generate-a-new-lock-address-to-receive-tokens",level:3},{value:"Build the Transaction",id:"build-the-transaction",level:3},{value:"Breakpoint Check",id:"breakpoint-check-1",level:3},{value:"Step 3: Prove Transaction",id:"step-3-prove-transaction",level:2},{value:"Breakpoint Check",id:"breakpoint-check-2",level:3},{value:"Step 4: Broadcast Transaction",id:"step-4-broadcast-transaction",level:2},{value:"Optional Step: Check Balance",id:"optional-step-check-balance",level:2},{value:"Putting It All Together",id:"putting-it-all-together",level:2},{value:"Next Steps",id:"next-steps",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,l.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"use-case"},"Use Case"),(0,l.kt)("p",null,"To load a new wallet with 100 LVL tokens from your Local Node."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Objectives:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Create and initialize a wallet"),(0,l.kt)("li",{parentName:"ul"},"Create an unproven transaction to transfer funds from the Genesis block to the wallet"),(0,l.kt)("li",{parentName:"ul"},"Prove the transaction"),(0,l.kt)("li",{parentName:"ul"},"Broascast the transaction to the local node")),(0,l.kt)("h2",{id:"set-up"},"Set-Up"),(0,l.kt)("p",null,"Get started with launching a Local Node:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("a",{parentName:"li",href:"https://docs.docker.com/get-docker/"},"Get Docker")),(0,l.kt)("li",{parentName:"ol"},"Pull latest node image",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"}," docker pull docker.io/toplprotocol/bifrost-node:2.0.0-alpha10\n"))),(0,l.kt)("li",{parentName:"ol"},"Run a node",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"}," docker run --rm -p 9085:9085 -p 9084:9084 -p 9091:9091 docker.io/toplprotocol/bifrost-node:2.0.0-alpha10\n")))),(0,l.kt)("h2",{id:"step-1-create-and-initialize-a-wallet"},"Step 1: Create and Initialize a Wallet"),(0,l.kt)("p",null,"Before we can load a wallet with funds, we need to create the wallet. There are 2 steps to this process: creating the wallet's\nTopl main key and initializing the wallet state."),(0,l.kt)("h3",{id:"create-the-wallets-topl-main-key"},"Create the Wallet's Topl Main Key"),(0,l.kt)("p",null,"We will generate a new Topl Main Key for the wallet using ",(0,l.kt)("inlineCode",{parentName:"p"},"createAndSaveNewWallet"),". This will also save the keyfile and\nmnemonic to the local file system. See ",(0,l.kt)("a",{parentName:"p",href:"../../reference/wallets/create"},"Create a Wallet"),"."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Initialize a Wallet Key API to persist the keyfile and mnemonic. Here we are using the provided default implementation\nprovided by the Service Kit to persist to the local file system.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val walletKeyApi = WalletKeyApi.make[IO]()\n"))),(0,l.kt)("li",{parentName:"ol"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletKeyApi")," created above, initialize a Wallet Api",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val walletApi = WalletApi.make(walletKeyApi)\n"))),(0,l.kt)("li",{parentName:"ol"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletApi")," created above, create and persist a new wallet using ",(0,l.kt)("inlineCode",{parentName:"li"},"createAndSaveNewWallet"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = "keyfile.json", mnemonicName = "mnemonic.txt")\n')))),(0,l.kt)("h3",{id:"initialize-the-wallet-state"},"Initialize the Wallet State"),(0,l.kt)("p",null,"We will initialize the wallet state using ",(0,l.kt)("inlineCode",{parentName:"p"},"initWalletState"),". Here we are using the provided default implementation\nprovided by the Service Kit to persist to a SQLite database file. See ",(0,l.kt)("a",{parentName:"p",href:"../../reference/wallet-state#initialize-wallet-state"},"Initialize Wallet State")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"With the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletApi")," created in the previous section, initialize a Wallet State API",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'val walletStateApi = WalletStateApi.make[IO](WalletStateResource.walletResource("wallet.db"), walletApi)\n'))),(0,l.kt)("li",{parentName:"ol"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"walletResult")," created above, extract the Topl main key.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'mainKeyPair <- walletApi.extractMainKey(walletResult.mainKeyVaultStore, "password".getBytes())\n'))),(0,l.kt)("li",{parentName:"ol"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"mainKeyPair")," created above, derive a child key at (1, 1).",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"childKeyPair <- walletApi.deriveChildKeysPartial(mainKeyPair, 1, 1)\n"))),(0,l.kt)("li",{parentName:"ol"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"childKeyPair")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"walletStateApi")," created above, initialize the wallet state using ",(0,l.kt)("inlineCode",{parentName:"li"},"initWalletState"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, childKeyPair.vk)\n")))),(0,l.kt)("h3",{id:"breakpoint-check"},"Breakpoint Check"),(0,l.kt)("p",null,"At this point, your code should look something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.constants.NetworkConstants.{PRIVATE_NETWORK_ID, MAIN_LEDGER_ID}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n   val filePath = Paths.get(tutorialDir, fileName).toString\n   new File(filePath).delete() // Clear the file if it already exists\n   filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n   walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n   mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n   childKeyPair <- walletApi.deriveChildKeysPartial(mainKeyPair.toOption.get, 1, 1)\n   _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, childKeyPair.vk)\n} yield mainKeyPair\n\ninitializeWallet.unsafeRunSync()\n')),(0,l.kt)("p",null,"Running this code would create 3 files in your home directory: ",(0,l.kt)("inlineCode",{parentName:"p"},"keyfile.json"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"mnemonic.txt"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"wallet.db"),"."),(0,l.kt)("h2",{id:"step-2-create-transaction"},"Step 2: Create Transaction"),(0,l.kt)("p",null,"After you have a wallet initialized, the next step is to build a transaction that will populate your wallet with some funds.\nThis transaction should transfer funds from the Genesis block to your wallet."),(0,l.kt)("h3",{id:"query-genesis-funds"},"Query Genesis Funds"),(0,l.kt)("p",null,"The Genesis block encumbers tokens with a height lock. To retrieve these tokens, we need to create the LockAddress for this Height Lock.\nThis LockAddress will also be used as the change address for the transaction (any excess funds will go back to this Address)."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Retrieve HeightLock from the Wallet State API. Since we are using the provided default implementation of the Wallet State API,\nwe can retrieve the HeightLock using the following code:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'heightLock <- walletStateApi.getLock("nofellowship", "genesis", 0)\n'))),(0,l.kt)("li",{parentName:"ol"},"Create a LockAddress from the HeightLock retrieved in the previous step. See ",(0,l.kt)("a",{parentName:"li",href:"../../reference/locks/create-lock-addr"},"Initialize Wallet State"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"heightAddress <- TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).lockAddress(heightLock)\n"))),(0,l.kt)("li",{parentName:"ol"},"With the LockAddress created in the previous step, we can query the Genesis block for funds. This will return a list of UTXOs\nwhich will be the inputs for the transaction. See ",(0,l.kt)("a",{parentName:"li",href:"../../reference/rpc#querying-utxos"},"Querying UTXOs"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'genusQueryApi = GenusQueryAlgebra.make[IO](RpcChannelResource.channelResource[IO]("localhost", 9084, false))\ntxos <- genusQueryApi.queryUtxo(heightAddress)\n')))),(0,l.kt)("h3",{id:"generate-a-new-lock-address-to-receive-tokens"},"Generate a New Lock Address to Receive Tokens"),(0,l.kt)("p",null,"To receive the funds, we need to generate a LockAddress for which the funds will be transferred to (i.e, an output in\nthe transaction). This LockAddress that will encumber our new funds will be generated from our wallet. This will allow us\nto prove ownership once we want to spend the funds. For this tutorial, we will generate a LockAddress for a 1-of-1\nDigital Signature Lock."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Retrieve a 1-of-1 Signature Lock from the Wallet State API. Since we are using the provided default implementation of the Wallet State API,\nwe can retrieve the Signature Lock using the following code:",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'sigLock <- walletStateApi.getLock("self", "default", 1)\n'))),(0,l.kt)("li",{parentName:"ol"},"Create a LockAddress from the Signature Lock retrieved in the previous step.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"sigAddress <- TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).lockAddress(sigLock)\n")))),(0,l.kt)("h3",{id:"build-the-transaction"},"Build the Transaction"),(0,l.kt)("p",null,"Using everything we generated in this section, we can finally build the transaction using the Transaction Builder API.\nSee ",(0,l.kt)("a",{parentName:"p",href:"../../reference/transactions/transfer"},"Build Transfer Transaction"),". For this tutorial, we will transfer 100 LVLs\nto our wallet. The excess funds will be sent back to the Genesis LockAddress."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID).buildTransferAmountTransaction(\n   LvlType, // We are transferring LVLs\n   txos,  // The UTXOs we queried from the Genesis block in "Query Genus Funds"\n   heightLock.getPredicate, // The HeightLock we retrieved in "Query Genus Funds" \n   100L, // The amount of LVLs we want to transfer\n   sigAddress, // Our LockAddress that we generated in "Generate a New Lock Address to Receive Tokens"\n   heightAddress, // The LockAddress to send back change that we generated in "Query Genus Funds"\n   1L // An arbitrary fee amount\n)\n')),(0,l.kt)("h3",{id:"breakpoint-check-1"},"Breakpoint Check"),(0,l.kt)("p",null,"At this point, your code should look something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.LvlType\nimport co.topl.brambl.wallet.WalletApi\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n   val filePath = Paths.get(tutorialDir, fileName).toString\n   new File(filePath).delete() // Clear the file if it already exists\n   filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  childKeyPair <- walletApi.deriveChildKeysPartial(mainKeyPair.toOption.get, 1, 1)\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, childKeyPair.vk)\n} yield mainKeyPair\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n    _ <- initializeWallet\n    heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)\n    heightAddress <- txBuilder.lockAddress(heightLock.get)\n    txos <- genusQueryApi.queryUtxo(heightAddress)\n    sigLock <- walletStateApi.getLock("self", "default", 1)\n    sigAddress <- txBuilder.lockAddress(sigLock.get)\n    tx <- txBuilder.buildTransferAmountTransaction(\n      LvlType,\n      txos,\n      heightLock.get.getPredicate,\n      100L,\n      sigAddress,\n      heightAddress,\n      1L\n    )\n} yield tx.toOption.get\n\nunprovenTransaction.unsafeRunSync()\n')),(0,l.kt)("h2",{id:"step-3-prove-transaction"},"Step 3: Prove Transaction"),(0,l.kt)("p",null,'In order for the funds to be transferred, we need to prove the Lock encumbering the funds in the Genesis block. You can think of this as\n"unlocking" the funds. See ',(0,l.kt)("a",{parentName:"p",href:"../../reference/prove"},"Prove Transaction"),". It is best practice to validate the transaction as well."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Create a Credentialler using your Topl main key.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n"))),(0,l.kt)("li",{parentName:"ol"},"Create a context in which we will validate the transaction against. Ideally, this context should represent the current\ncontext of the node as best as possible. This is more important for validating Locks that contain Height or Tick range\npropositions. In our case, the Genesis Height Lock will be satisfied by a header height in between ",(0,l.kt)("inlineCode",{parentName:"li"},"1")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Long.MaxValue"),"\nso for our tutorial, we can choose any height and tick.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'ctx = Context[IO](unprovenTransaction, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)\n'))),(0,l.kt)("li",{parentName:"ol"},"Prove and validate the unproven transaction from the previous section. If the transaction is valid, the proven transaction\nwill be returned. If the transaction is invalid, the validation errors will be returned.",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"credentialler.proveAndValidate(tx, validCtx)\n")))),(0,l.kt)("h3",{id:"breakpoint-check-2"},"Breakpoint Check"),(0,l.kt)("p",null,"At this point, your code should look something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.{Datum, Event}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.LvlType\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n   val filePath = Paths.get(tutorialDir, fileName).toString\n   new File(filePath).delete() // Clear the file if it already exists\n   filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  childKeyPair <- walletApi.deriveChildKeysPartial(mainKeyPair.toOption.get, 1, 1)\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, childKeyPair.vk)\n} yield mainKeyPair\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n    _ <- initializeWallet\n    heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)\n    heightAddress <- txBuilder.lockAddress(heightLock.get)\n    txos <- genusQueryApi.queryUtxo(heightAddress)\n    sigLock <- walletStateApi.getLock("self", "default", 1)\n    sigAddress <- txBuilder.lockAddress(sigLock.get)\n    tx <- txBuilder.buildTransferAmountTransaction(\n      LvlType,\n      txos,\n      heightLock.get.getPredicate,\n      100L,\n      sigAddress,\n      heightAddress,\n      1L\n    )\n} yield tx.toOption.get\n\nval proveAndValidateResult = for {\n  tx <- unprovenTransaction\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  ctx = Context[IO](tx, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res\n\nproveAndValidateResult.unsafeRunSync()\n')),(0,l.kt)("h2",{id:"step-4-broadcast-transaction"},"Step 4: Broadcast Transaction"),(0,l.kt)("p",null,"The last step is to broadcast the transaction to the network. See ",(0,l.kt)("a",{parentName:"p",href:"../../reference/rpc#broadcast-a-transaction"},"Broadcast a Transaction"),".\nThe ",(0,l.kt)("inlineCode",{parentName:"p"},"channelResource")," can be the same as the one used for ",(0,l.kt)("inlineCode",{parentName:"p"},"genusQueryApi")," in a previous section."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},"val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n   provenTx <- proveAndValidateResult\n   txId <- bifrostQuery.broadcastTransaction(provenTx.toOption.get)\n} yield txId\n")),(0,l.kt)("h2",{id:"optional-step-check-balance"},"Optional Step: Check Balance"),(0,l.kt)("p",null,"If everything went well, you will soon have the funds available in your wallet. You can check your balance by querying the\nGenus node for funds encumbered by your ",(0,l.kt)("inlineCode",{parentName:"p"},"sigAddress"),". See ",(0,l.kt)("a",{parentName:"p",href:"../../reference/rpc#querying-utxos"},"Querying UTXOs"),"."),(0,l.kt)("p",null,"You should allow some time for the transaction to be processed by the network."),(0,l.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,l.kt)("p",null,"At this point, your code should look something like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.arrow.FunctionK\nimport cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.{Datum, Event}\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}\nimport co.topl.brambl.syntax.{LvlType, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps, int128AsBigInt}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\n\nimport java.io.File\nimport java.nio.file.Paths\n\nimplicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]\n\n// Replace with the desired location for your tutorial directory\nval tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString\nnew File(tutorialDir).mkdirs() // Create the directory if it doesn\'t exist\n\ndef initFilePath(fileName: String): String = {\n   val filePath = Paths.get(tutorialDir, fileName).toString\n   new File(filePath).delete() // Clear the file if it already exists\n   filePath\n}\n\n// Replace with the desired location for your key file\nval keyFile = initFilePath("keyfile.json")\n// Replace with the desired location of for your mnemonic file\nval mnemonicFile = initFilePath("mnemonic.txt")\n// Replace with the desired location of for your wallet state DB file\nval walletDb = initFilePath("wallet.db")\n\nval walletKeyApi = WalletKeyApi.make[IO]()\nval walletApi = WalletApi.make(walletKeyApi)\nval conn = WalletStateResource.walletResource(walletDb)\nval walletStateApi = WalletStateApi.make[IO](conn, walletApi)\n\nval initializeWallet = for {\n  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)\n  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())\n  childKeyPair <- walletApi.deriveChildKeysPartial(mainKeyPair.toOption.get, 1, 1)\n  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, childKeyPair.vk)\n} yield mainKeyPair\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\nval genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)\nval txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\n\nval unprovenTransaction = for {\n    _ <- initializeWallet\n    heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)\n    heightAddress <- txBuilder.lockAddress(heightLock.get)\n    txos <- genusQueryApi.queryUtxo(heightAddress)\n    sigLock <- walletStateApi.getLock("self", "default", 1)\n    sigAddress <- txBuilder.lockAddress(sigLock.get)\n    tx <- txBuilder.buildTransferAmountTransaction(\n      LvlType,\n      txos,\n      heightLock.get.getPredicate,\n      100L,\n      sigAddress,\n      heightAddress,\n      1L\n    )\n} yield tx.toOption.get\n\nval proveAndValidateResult = for {\n  tx <- unprovenTransaction\n  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)\n  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)\n  ctx = Context[IO](tx, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)\n  res <- credentialler.proveAndValidate(tx, ctx)\n} yield res\n\nval bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)\n\nval broadcastTransaction = for {\n  provenTx <- proveAndValidateResult\n  txId <- bifrostQuery.broadcastTransaction(provenTx.toOption.get)\n} yield txId\n\nbroadcastTransaction.unsafeRunSync()\n\n// Allow some time to pass before querying the transaction\nThread.sleep(15000)\n\n// optionally view your funds\nval queryFunds = for {\n  sigLock <- walletStateApi.getLock("self", "default", 1)\n  sigAddress <- txBuilder.lockAddress(sigLock.get)\n  txos <- genusQueryApi.queryUtxo(sigAddress)\n} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")\n\nqueryFunds.unsafeRunSync().foreach(println)\n')),(0,l.kt)("p",null,"If all went well, you should see that you have 100 LVLs in encumbered by your ",(0,l.kt)("inlineCode",{parentName:"p"},"sigAddress")," ready to be spent by you."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"LvlType: 100\n")),(0,l.kt)("h2",{id:"next-steps"},"Next Steps"),(0,l.kt)("p",null,"Read our other tutorials to learn how to spend the funds you just transferred to your wallet."))}u.isMDXComponent=!0}}]);