"use strict";(self.webpackChunkbramblsc_documentation=self.webpackChunkbramblsc_documentation||[]).push([[407],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(a),u=r,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7884:(e,t,a)=>{a.d(t,{Z:()=>l});var n=a(7294),r=a(9960),o=a(6550),i=a(8084);function l(e){let{children:t,path:a}=e;var l=function(){const{pathname:e}=(0,o.TH)(),{versions:t}=(0,i.eZ)("docusaurus-plugin-content-docs");return t.find((t=>{let{path:a}=t;return e.startsWith(a)})).name||"current"}();return n.createElement(r.Z,{to:`/scaladoc/${l}/${a}`,target:"_blank"},t)}},7203:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905)),o=a(7884);const i={sidebar_position:7,title:"Prove a Transaction",description:"Prove a transaction."},l=void 0,s={unversionedId:"reference/prove",id:"reference/prove",title:"Prove a Transaction",description:"Prove a transaction.",source:"@site/docs/reference/prove.mdx",sourceDirName:"reference",slug:"/reference/prove",permalink:"/BramblSc/docs/current/reference/prove",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Prove a Transaction",description:"Prove a transaction."},sidebar:"referenceSidebar",previous:{title:"Transfer Tokens",permalink:"/BramblSc/docs/current/reference/transactions/transfer"},next:{title:"Broadcast a Transaction",permalink:"/BramblSc/docs/current/reference/broadcast"}},p={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Prove",id:"prove",level:2},{value:"Example",id:"example",level:3},{value:"Prove and Validate",id:"prove-and-validate",level:2},{value:"Example",id:"example-1",level:3}],d={toc:c},m="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Before you can broadcast a ",(0,r.kt)("a",{parentName:"p",href:"./transactions"},"newly created transaction")," to the blockchain, you must prove that you have the authority to\nspend the input tokens. You can accomplish this using the SDK's Credentialler."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"The following requires access to a Credentialler instance. You can initialize one using the following snippet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val credentialler = CredentiallerInterpreter.make[F](walletApi, walletStateApi, mainKey)\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," is a type parameter bound to a context parameter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad[F]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"walletApi")," is an instance of\na ",(0,r.kt)("a",{parentName:"p",href:"./wallets#prerequisites"},"Wallet Api"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"walletStateApi")," is an initialized instance of\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/dataApi/WalletStateAlgebra.html",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"WalletStateAlgebra")),",\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"mainKey")," is your ExtendedEd25519 Topl main key pair. See the ",(0,r.kt)("inlineCode",{parentName:"p"},"make"),"\nfunction's ",(0,r.kt)(o.Z,{path:"co/topl/brambl/wallet/CredentiallerInterpreter$.html#make[F[_]](WalletApi[F],WalletStateAlgebra[F],KeyPair)(Monad[F]):Credentialler[F]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"signature")),".\nFor example, if you are using Cats Effect ",(0,r.kt)("inlineCode",{parentName:"p"},"IO")," and the default implementation of\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/servicekit/index.html",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"ServiceKit")),", you can initialize\na Credentialler as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport co.topl.brambl.servicekit.WalletStateResource\nimport co.topl.crypto.signing.ExtendedEd25519\nimport co.topl.brambl.syntax.cryptoToPbKeyPair\n\n// Replace with the location of your wallet state file\nval DB_FILE = "wallet.db"\nval walletConnection = WalletStateResource.walletResource(DB_FILE)\n\nval walletApi = WalletApi.make[IO](WalletKeyApi.make())\nval walletStateApi = WalletStateApi.make[IO](walletConnection, walletApi)\n// Some mock key pair. Do not use. Replace with your Topl main key pair.\nval mainKey = (new ExtendedEd25519).deriveKeyPairFromSeed(Array.fill(96)(0: Byte))\n\n// Credentialler initialization starts:\nval credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n')),(0,r.kt)("h2",{id:"prove"},"Prove"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Proving a transaction does not guarantee that the transaction will be accepted by the network. The transaction may still be\nrejected if it is malformed or if it is not sufficiently proven. For this reason, it is recommended to use\nthe ",(0,r.kt)("a",{parentName:"p",href:"#prove-and-validate"},(0,r.kt)("inlineCode",{parentName:"a"},"proveAndValidate"))," function instead.")),(0,r.kt)("p",null,"You can prove a transaction using\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/wallet/Credentialler.html#prove(IoTransaction):F[IoTransaction]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"prove")),"\nfunction of a Credentialler instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def prove(\n  unprovenTx: IoTransaction\n): F[IoTransaction]\n")),(0,r.kt)("p",null,"This function takes in a transaction and proves every input by updating their attestations. Any existing proofs are persisted.\nThis is useful for partial proofs. For example, if an input is encumbered by an ",(0,r.kt)("inlineCode",{parentName:"p"},"And")," lock, a partial proof could be that\nonly one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"And")," lock's sub-propositions is proven. In this case, calling this function will add the proof for the\nsecond sub-proposition while leaving the first sub-proposition's proof intact."),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unprovenTx"),": The transaction to prove. As mentioned above, this transaction may already have some proofs. To obtain\na new transaction with no proofs, read ",(0,r.kt)("a",{parentName:"li",href:"./transactions"},"Build a Transaction"))),(0,r.kt)("p",null,"On success, this function returns the given transaction with updated proofs which can be broadcasted to the network.\nThis returned ",(0,r.kt)("inlineCode",{parentName:"p"},"IoTransaction")," has the same signable bytes as the original transaction. If any of the contained propositions\nare unable to be proven, their proofs will be left unchanged."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"The following example shows how to prove a transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.builders.locks.LockTemplate\nimport co.topl.brambl.builders.locks.PropositionTemplate.HeightTemplate\nimport co.topl.brambl.builders.locks.LockTemplate.PredicateTemplate\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.servicekit.WalletStateResource\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport co.topl.crypto.signing.ExtendedEd25519\nimport co.topl.brambl.syntax.cryptoToPbKeyPair\n\n// Replace with the location of your wallet state file\nval walletConnection = WalletStateResource.walletResource("wallet.db")\n\n// Some mock key pair. Do not use. Replace with your Topl main key pair.\nval mainKey = (new ExtendedEd25519).deriveKeyPairFromSeed(Array.fill(96)(0: Byte))\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\n// Mock address. Replace with recipient address.\nval toAddr = decodeAddress("ptetP7jshHTuV9bmPmtVLm6PtUzBMZ8iYRvAxvbGTJ5VgiEPHqCCnZ8MLLdi").toOption.get\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\nval walletApi = WalletApi.make[IO](WalletKeyApi.make())\nval walletStateApi = WalletStateApi.make[IO](walletConnection, walletApi)\nval credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n\n// The predicate lock of the input to send.\nval predicateTemplate: LockTemplate[IO] = PredicateTemplate[IO](Seq(HeightTemplate("header", 1, Long.MaxValue)), 1)\n\nval tx = for {\n  fromLock <- predicateTemplate.build(List.empty).map(_.toOption.get)\n  fromAddr <- transactionBuilderApi.lockAddress(fromLock)\n  fromTxos <- GenusQueryAlgebra.make[IO](channelResource).queryUtxo(fromAddr)\n  unprovenTx <- transactionBuilderApi.buildTransferAllTransaction(fromTxos, fromLock.getPredicate, toAddr, toAddr, 1L)\n  // Proving begins here:\n  // highlight-next-line\n  provenTx <- credentialler.prove(unprovenTx.toOption.get)\n} yield provenTx\n\ntx.unsafeRunSync()\n')),(0,r.kt)("h2",{id:"prove-and-validate"},"Prove and Validate"),(0,r.kt)("p",null,"You can prove ",(0,r.kt)("strong",{parentName:"p"},"and")," validate a transaction using\nthe ",(0,r.kt)(o.Z,{path:"co/topl/brambl/wallet/Credentialler.html#proveAndValidate(IoTransaction,Context[F]):F[Either[List[ValidationError],IoTransaction]]",mdxType:"ScaladocLink"},(0,r.kt)("code",null,"proveAndValidate")),"\nfunction of a Credentialler instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def proveAndValidate(\n  unprovenTx: IoTransaction,\n  ctx:        Context[F]\n): F[Either[List[ValidationError], IoTransaction]]\n")),(0,r.kt)("p",null,"This function consists of two steps. The first step proves the transaction the same way as the\n",(0,r.kt)("a",{parentName:"p",href:"#prove"},(0,r.kt)("inlineCode",{parentName:"a"},"prove"))," function. The second step validates the transaction by checking that the transaction is well-formed (syntax check)\nand that the transaction is sufficiently proven (authorization check). Any validation failures will need to be addressed\nbefore the transaction can be broadcasted to the network."),(0,r.kt)("p",null,"The parameters are as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"unprovenTx"),": The transaction to prove and validate. Similar to the ",(0,r.kt)("a",{parentName:"li",href:"#prove"},(0,r.kt)("inlineCode",{parentName:"a"},"prove"))," function, this transaction may\nalready have some proofs. To obtain a new transaction with no proofs, read ",(0,r.kt)("a",{parentName:"li",href:"./transactions"},"Build a Transaction"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ctx"),": The context to use for validation. This context aims to mock the context used by the bifrost node. It is up to the\nuser to provide a context that is appropriate, specifically, providing appropriate values for the current tick and current block\nheader height. Since this mock context is not guaranteed to have the same current tick and same current block header height\nas the bifrost node at the time of server-side validation, the results of validating any ",(0,r.kt)("inlineCode",{parentName:"li"},"TickRange")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"HeightRange")," propositions\nmay differ from the results of validating the same propositions on the bifrost node.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The bifrost node performs an additional semantic validation check that is not performed by this function. For example, the bifrost node\nchecks that the transaction is not a double spend, i.e, the transaction inputs actually exist at the current state of the chain.\nDue to this, server-side validation may fail when client-side validation succeeds, even with the same context.")),(0,r.kt)("p",null,"On success, the function returns the given transaction with updated proofs which can be broadcasted to the network. This returned\n",(0,r.kt)("inlineCode",{parentName:"p"},"IoTransaction")," has the same signable bytes as the original transaction. If any of the contained propositions are unable to be proven,\ntheir proofs will be left unchanged. On failure, the function returns a list of the validation errors."),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)("p",null,"The following shows examples of how to prove and validate a transaction. The first example illustrates using a context that\nsatisfies the height proposition in the transaction. The second example illustrates using a context that does not satisfy the proposition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.IO\nimport cats.effect.unsafe.implicits.global\nimport co.topl.brambl.Context\nimport co.topl.brambl.builders.TransactionBuilderApi\nimport co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}\nimport co.topl.brambl.builders.locks.LockTemplate\nimport co.topl.brambl.builders.locks.PropositionTemplate.HeightTemplate\nimport co.topl.brambl.builders.locks.LockTemplate.PredicateTemplate\nimport co.topl.brambl.codecs.AddressCodecs.decodeAddress\nimport co.topl.brambl.dataApi.{GenusQueryAlgebra, RpcChannelResource}\nimport co.topl.brambl.models.{Datum, Event}\nimport co.topl.brambl.servicekit.WalletStateResource\nimport co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi}\nimport co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}\nimport co.topl.crypto.signing.ExtendedEd25519\nimport co.topl.brambl.syntax.cryptoToPbKeyPair\n\n// Replace with the location of your wallet state file\nval walletConnection = WalletStateResource.walletResource("wallet.db")\n\n// Some mock key pair. Do not use. Replace with your Topl main key pair.\nval mainKey = (new ExtendedEd25519).deriveKeyPairFromSeed(Array.fill(96)(0: Byte))\n\n// Replace with the address and port of your node\'s gRPC endpoint\nval channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)\n\n// Mock address. Replace with recipient address.\nval toAddr = decodeAddress("ptetP7jshHTuV9bmPmtVLm6PtUzBMZ8iYRvAxvbGTJ5VgiEPHqCCnZ8MLLdi").toOption.get\n\nval transactionBuilderApi = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)\nval walletApi = WalletApi.make[IO](WalletKeyApi.make())\nval walletStateApi = WalletStateApi.make[IO](walletConnection, walletApi)\nval credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey)\n\n// The predicate lock of the input to send.\nval predicateTemplate: LockTemplate[IO] = PredicateTemplate[IO](Seq(HeightTemplate("header", 1, Long.MaxValue)), 1)\n// Mock current height of the node. validHeight satisfies the predicate, invalidHeight does not.\nval validHeight = "header" -> Datum().withHeader(Datum.Header(Event.Header(50)))\nval invalidHeight = "header" -> Datum().withHeader(Datum.Header(Event.Header(0)))\n\nval unprovenTx = for {\n  fromLock <- predicateTemplate.build(List.empty).map(_.toOption.get)\n  fromAddr <- transactionBuilderApi.lockAddress(fromLock)\n  fromTxos <- GenusQueryAlgebra.make[IO](channelResource).queryUtxo(fromAddr)\n  unprovenTxRes <- transactionBuilderApi.buildTransferAllTransaction(fromTxos, fromLock.getPredicate, toAddr, toAddr, 1L)\n} yield unprovenTxRes.toOption.get\n\n// Prove and Validate begins here:\n\nval validRes = unprovenTx flatMap { tx =>\n  val validCtx = Context[IO](tx, 1, Map(validHeight).lift)\n  credentialler.proveAndValidate(tx, validCtx)\n}\nval provenTx = validRes.unsafeRunSync()\n\nval invalidRes = unprovenTx flatMap { tx =>\n  val invalidCtx = Context[IO](tx, 1, Map(invalidHeight).lift)\n  // highlight-next-line\n  credentialler.proveAndValidate(tx, invalidCtx)\n}\nval validationErrs = invalidRes.unsafeRunSync()\n')))}u.isMDXComponent=!0}}]);