---
sidebar_position: 4
title: Merge Assets
description: Merge Compatible Assets Into a Single Alloy Asset
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Use Case

TBD
"For the purposes of this tutorial " > Primary and secondary. Mention this tutorial builds upon the other tutorials
it will go a lot more smoothly if you have already completed them in order.

**Objectives:**
- TBD

## Set-Up

To follow along with this tutorial, you will need to initialize and fund a wallet with some LVLs. 

If you were following the instructions in the [Load Wallet with Funds](./obtain-funds) tutorial, the code to set up the 
Senders wallet should look something like:

```scala title="Initializing a Wallet and Funding it with LVLs"
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.{Datum, Event}
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{LvlType, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps, int128AsBigInt}
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}

import java.io.File
import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
new File(tutorialDir).mkdirs() // Create the directory if it doesn't exist

def initFilePath(fileName: String): String = {
  val filePath = Paths.get(tutorialDir, fileName).toString
  new File(filePath).delete() // Clear the file if it already exists
  filePath
}

// Replace with the desired location for your key file
val keyFile = initFilePath("keyfile.json")
// Replace with the desired location of for your mnemonic file
val mnemonicFile = initFilePath("mnemonic.txt")
// Replace with the desired location of for your wallet state DB file
val walletDb = initFilePath("wallet.db")

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val conn = WalletStateResource.walletResource(walletDb)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)

val initializeWallet = for {
  walletResult <- walletApi.createAndSaveNewWallet[IO]("password".getBytes, name = keyFile, mnemonicName = mnemonicFile)
  mainKeyPair <- walletApi.extractMainKey(walletResult.toOption.get.mainKeyVaultStore, "password".getBytes())
  _ <- walletStateApi.initWalletState(PRIVATE_NETWORK_ID, MAIN_LEDGER_ID, mainKeyPair.toOption.get)
} yield mainKeyPair

// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  _ <- initializeWallet
  heightLock <- walletStateApi.getLock("nofellowship", "genesis", 1)
  heightAddress <- txBuilder.lockAddress(heightLock.get)
  txos <- genusQueryApi.queryUtxo(heightAddress)
  sigLock <- walletStateApi.getLock("self", "default", 1)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  tx <- txBuilder.buildTransferAmountTransaction(
    LvlType,
    txos,
    heightLock.get.getPredicate,
    100L,
    sigAddress,
    heightAddress,
    1L
  )
} yield tx.toOption.get

val proveAndValidateResult = for {
  tx <- unprovenTransaction
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  ctx = Context[IO](tx, 50, Map("header" -> Datum().withHeader(Datum.Header(Event.Header(50)))).lift)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res

val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  provenTx <- proveAndValidateResult
  txId <- bifrostQuery.broadcastTransaction(provenTx.toOption.get)
} yield txId

broadcastTransaction.unsafeRunSync()

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

// optionally view your funds
val queryFunds = for {
  sigLock <- walletStateApi.getLock("self", "default", 1)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value => s"${value.typeIdentifier}: ${value.quantity.intValue}")

queryFunds.unsafeRunSync().foreach(println)
```

After running that file, you should see that the Sender's wallet has been initialized with 100 LVLs:

```bash title="output"
LvlType: 100
```

Keep the same local node instance running. We will be using it for the rest of this tutorial.

## Step 1: Mint Group and Series Constructor Tokens 

TBD > Very similar to asset minting. explain the differences (we need 2 series constructor tokens)

TBD > Add it into tabs (Group, Primary Series, Secondary Series)

Your code should look something like this:

<Tabs>
  <TabItem value="group" label="Mint Group Constructor Tokens">

```scala
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Event.GroupPolicy
import co.topl.brambl.models.Indices
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 1)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  groupPolicy = GroupPolicy("Group Policy Label", txos.head.outputAddress)
  outputLock <- walletStateApi.getLock("self", "default", 2)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/2 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 2)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 2)
  )
  tx <- txBuilder.buildGroupMintingTransaction(
    txos,
    inputLock.get.getPredicate,
    groupPolicy,
    5L,
    outputAddress,
    outputAddress,
    1L
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 2)
  sigLock <- walletStateApi.getLock("self", "default", 2)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

  </TabItem>
  <TabItem value="series_1" label="Mint Primary Series Constructor Tokens">

```scala
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Event.SeriesPolicy
import co.topl.brambl.models.Indices
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{LvlType, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 2)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  seriesPolicy = SeriesPolicy(
    "Primary Series Policy Label",
    registrationUtxo = txos.filter(_.transactionOutput.value.value.typeIdentifier == LvlType).head.outputAddress
  )
  outputLock <- walletStateApi.getLock("self", "default", 3)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/3 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 3)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 3)
  )
  tx <- txBuilder.buildSeriesMintingTransaction(
    txos,
    inputLock.get.getPredicate,
    seriesPolicy,
    5L,
    outputAddress,
    outputAddress,
    1L
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 3)
  sigLock <- walletStateApi.getLock("self", "default", 3)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

  </TabItem>
  <TabItem value="series_2" label="Mint Secondary Series Constructor Tokens">

```scala
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Event.SeriesPolicy
import co.topl.brambl.models.Indices
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{LvlType, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 3)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  seriesPolicy = SeriesPolicy(
    "Secondary Series Policy Label",
    registrationUtxo = txos.filter(_.transactionOutput.value.value.typeIdentifier == LvlType).head.outputAddress
  )
  outputLock <- walletStateApi.getLock("self", "default", 4)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/4 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 4)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 4)
  )
  tx <- txBuilder.buildSeriesMintingTransaction(
    txos,
    inputLock.get.getPredicate,
    seriesPolicy,
    5L,
    outputAddress,
    outputAddress,
    1L
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 4)
  sigLock <- walletStateApi.getLock("self", "default", 4)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

  </TabItem>
</Tabs>

Try running the code. If all went well, you should see that you have 99 LVLs and 5 Group Constructor Token in your wallet,
ready to be spent by you.

```bash title="output"
LvlType$: 99
GroupType: 5
```

Keep the same local node instance running.

## Step 2: Mint Asset Tokens

TBD > Very similar to asset minting. explain the differences (using 2 different series constructor tokens to create compatible assets)

TBD > Add it into tabs (Primary Asset, Secondary Asset)

Your code should look something like this:

<Tabs>
  <TabItem value="asset_1" label="Mint Primary Asset Tokens">

```scala
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Indices
import co.topl.brambl.models.box.AssetMintingStatement
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{bigIntAsInt128, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 4)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  mintingStatement = AssetMintingStatement(
    txos.filter(_.transactionOutput.value.value.isGroup).head.outputAddress,
    txos.filter(_.transactionOutput.value.value.isSeries).head.outputAddress,
    BigInt(10)
  )
  outputLock <- walletStateApi.getLock("self", "default", 5)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/5 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 5)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 5)
  )
  tx <- txBuilder.buildAssetMintingTransaction(
    mintingStatement,
    txos,
    Map(inputAddress -> inputLock.get.getPredicate),
    1L,
    outputAddress,
    outputAddress
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 5)
  sigLock <- walletStateApi.getLock("self", "default", 5)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

  </TabItem>
  <TabItem value="asset_2" label="Mint Secondary Asset Tokens">

```scala
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Indices
import co.topl.brambl.models.box.AssetMintingStatement
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{bigIntAsInt128, int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 5)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  mintingStatement = AssetMintingStatement(
    txos.filter(_.transactionOutput.value.value.isGroup).head.outputAddress,
    txos.filter(_.transactionOutput.value.value.isSeries).head.outputAddress,
    BigInt(10)
  )
  outputLock <- walletStateApi.getLock("self", "default", 6)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/6 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 6)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 6)
  )
  tx <- txBuilder.buildAssetMintingTransaction(
    mintingStatement,
    txos,
    Map(inputAddress -> inputLock.get.getPredicate),
    1L,
    outputAddress,
    outputAddress
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 6)
  sigLock <- walletStateApi.getLock("self", "default", 6)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

  </TabItem>
</Tabs>

After ensuring that some time has passed since minting the Group Constructor Tokens from Step 1 (15-20 seconds), try 
running the code. If all went well, you should see that you have 98 LVLs, 5 Group Constructor Token, and 5 Series 
Constructor token in your wallet, ready to be spent by you.

```bash title="output"
GroupType: 5
LvlType$: 98
SeriesType: 5
```

Keep the same local node instance running.

## Step 3: Merge Primary and Secondary Asset Tokens

TBD > Detailed steps

Your code should look something like this:

```scala title="Merge Assets"
import cats.arrow.FunctionK
import cats.effect.IO
import cats.effect.unsafe.implicits.global
import co.topl.brambl.Context
import co.topl.brambl.builders.TransactionBuilderApi
import co.topl.brambl.builders.TransactionBuilderApi.implicits.lockAddressOps
import co.topl.brambl.constants.NetworkConstants.{MAIN_LEDGER_ID, PRIVATE_NETWORK_ID}
import co.topl.brambl.dataApi.{BifrostQueryAlgebra, GenusQueryAlgebra, RpcChannelResource}
import co.topl.brambl.models.Indices
import co.topl.brambl.servicekit.{WalletKeyApi, WalletStateApi, WalletStateResource}
import co.topl.brambl.syntax.{int128AsBigInt, valueToQuantitySyntaxOps, valueToTypeIdentifierSyntaxOps}
import co.topl.brambl.utils.Encoding
import co.topl.brambl.wallet.{CredentiallerInterpreter, WalletApi}
import quivr.models.VerificationKey

import java.nio.file.Paths

implicit val transformType: FunctionK[IO, IO] = FunctionK.id[IO]

// Replace with the desired location for your tutorial directory
val tutorialDir = Paths.get(System.getProperty("user.home"), "tutorial").toString
// Replace with the desired location for your key file
val keyFile = Paths.get(tutorialDir, "keyfile.json").toString
// Replace with the desired location of for your wallet state DB file
val walletDb = Paths.get(tutorialDir, "wallet.db").toString
val conn = WalletStateResource.walletResource(walletDb)
// Replace with the address and port of your node's gRPC endpoint
val channelResource = RpcChannelResource.channelResource[IO]("localhost", 9084, secureConnection = false)

val walletKeyApi = WalletKeyApi.make[IO]()
val walletApi = WalletApi.make(walletKeyApi)
val walletStateApi = WalletStateApi.make[IO](conn, walletApi)
val genusQueryApi = GenusQueryAlgebra.make[IO](channelResource)
val txBuilder = TransactionBuilderApi.make[IO](PRIVATE_NETWORK_ID, MAIN_LEDGER_ID)

val unprovenTransaction = for {
  inputLock <- walletStateApi.getLock("self", "default", 6)
  inputAddress <- txBuilder.lockAddress(inputLock.get)
  txos <- genusQueryApi.queryUtxo(inputAddress)
  outputLock <- walletStateApi.getLock("self", "default", 7)
  outputAddress <- txBuilder.lockAddress(outputLock.get)
  outputVk <- walletStateApi.getEntityVks("self", "default").map(_.get.head) flatMap { vk =>
    // Derive the verification key at path 1/1/7 (used in outputLock)
    walletApi.deriveChildVerificationKey(VerificationKey.parseFrom(Encoding.decodeFromBase58(vk).toOption.get), 7)
  }
  _ <- walletStateApi.updateWalletState(
    Encoding.encodeToBase58(outputLock.get.getPredicate.toByteArray),
    outputAddress.toBase58(),
    Some("ExtendedEd25519"),
    Some(Encoding.encodeToBase58(outputVk.toByteArray)),
    Indices(1, 1, 7)
  )
  utxosToMerge = txos.filter(_.transactionOutput.value.value.isAsset).map(_.outputAddress)
  tx <- txBuilder.buildAssetMergeTransaction(
    utxosToMerge,
    txos,
    Map(inputAddress -> inputLock.get.getPredicate),
    1L,
    outputAddress,
    outputAddress
  )
} yield tx.toOption.get

val provenTx = for {
  mainKey <- walletApi.loadAndExtractMainKey[IO]("password".getBytes, keyFile)
  credentialler = CredentiallerInterpreter.make[IO](walletApi, walletStateApi, mainKey.toOption.get)
  tx <- unprovenTransaction
  ctx = Context[IO](tx, 50, _ => None)
  res <- credentialler.proveAndValidate(tx, ctx)
} yield res.toOption.get


val bifrostQuery = BifrostQueryAlgebra.make[IO](channelResource)

val broadcastTransaction = for {
  tx <- provenTx
  _ <- bifrostQuery.broadcastTransaction(tx)
} yield ()

broadcastTransaction.unsafeRunSync()

val queryFunds = for {
  // The tokens were sent to the address derived from (self, default, 7)
  sigLock <- walletStateApi.getLock("self", "default", 7)
  sigAddress <- txBuilder.lockAddress(sigLock.get)
  txos <- genusQueryApi.queryUtxo(sigAddress)
} yield txos.map(_.transactionOutput.value.value).map(value =>
  s"${value.typeIdentifier.getClass.getSimpleName}: ${value.quantity.intValue}"
)

// Allow some time to pass before querying the transaction
Thread.sleep(15000)

queryFunds.unsafeRunSync().foreach(println)
```

TBD

```bash title="output"
TBD
```